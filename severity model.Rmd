---
title: "severity Model"
output: html_notebook
---

We now turn to the severity model to predict average cost per claim (ACPC). We will use the canonical growth curve on incremental ACPC changes as our starting point. This data is already available. 

# Data Prep
First test the severity data for uniqueness across reserving class.

```{r}
library(dplyr)
length(unique(eur.dat.cul.mth$NetPrem))
eur.dat.cul.mth%>%group_by(ReservingClass,YOA,SubClass)%>%summarise_all(last)%>%length()# length not the same
eur.dat.cul.mth%>%mutate(factor_net_prem = factor(NetPrem))%>%group_by(factor_net_prem)%>%summarise_all(last)%>%arrange(ReservingClass,YOA)%>%View()
# 
```

inspection reveals an additional subclass, and that "other" seems to be doubled up in terms of the number of unique premiums.
Conclusion: we preprocess and average in the cyber and non-unique other premiums, but summarise on reserving class. Only one country at the moment.

```{r}
severity_data = eur.dat.cul.mth%>%group_by(Country,ReservingClass,YOA,DevMth)%>%
  summarise(nzClm = sum(nzClm), Incurred=sum(Incurred))%>%
  mutate(ACPC = Incurred/nzClm,Country=factor(Country),ReservingClass=factor(ReservingClass))%>%
  filter(nzClm>0,Incurred>0)%>%
  arrange(Country,ReservingClass,YOA,DevMth)%>%
  mutate(ACPC_increment = ACPC - lag(ACPC, lag = 1, default = 0), 
         DevMthprev = lag(DevMth,lag = 1, default=0.1),
         year_segment = factor(paste0(ReservingClass,"-",YOA)),
         dev_year_segment = factor(paste0(ReservingClass,"-",YOA,"-",DevMth))
  )
```
# First model
add the incrementals and try to model them using brms and growth curves
```{r}
library(brms)

sev_functions = "
  real lognormal_lcdf_mod(real a,real b,real c){
  return lognormal_lcdf(a|b,c);
  }

real lognormal_lccdf_mod(real a,real b,real c){
  return lognormal_lccdf(a|b,c);
}


"

# writing the formula for the model 
formula_sev <- bf(ACPC_increment  ~ exp(ult+7+log_diff_exp(lognormal_lcdf_mod(DevMth,log(60)-2.3*exp(sigmadev)-exp(mudev),exp(sigmadev)),lognormal_lcdf_mod(DevMthprev,log(60)-2.3*exp(sigmadev)-exp(mudev),exp(sigmadev))))
                        #, nlf(sigma ~ exp(sigmastd-(exp(lambda)-log(0.01)/60)*DevMth))# expon ccdf for sigma. >99% dev by t=60
                        , nlf(sigma ~ exp(sigmastd-log(nzClm)+lognormal_lccdf_mod(DevMth,lambda,1)) )
                        , sigmastd ~ (1|ReservingClass)
                        , lambda ~ (1|ReservingClass)
                       ,mudev ~ (1|ReservingClass)+(1|year_segment)
                       ,sigmadev~ (1|ReservingClass)+(1|year_segment)
                       ,ult~ (1|ReservingClass)+(1|year_segment)
                        ,family = brmsfamily("gaussian",link = "identity",link_sigma = "identity")
                       ,nl=TRUE
                       )
                               

# specify std normal non-centred priors
mypriors_sev <- c(
  #prior(normal(0, 5), class = "Intercept",  dpar = "sigma"),
  prior(normal(0, 3), nlpar = "mudev"),
  prior(normal(0, 1), nlpar = "sigmadev"),
  prior(normal(0, 5), nlpar = "ult"),
  #prior(normal(0, 1),  nlpar = "sigmastd"),
  #prior(normal(0, 1),  nlpar = "lambda"),
  prior(normal(0, 5),  nlpar = "lambda")
  )
```

# severity model run

```{r}
library(brms)
library(dplyr)
model_sev = brm(
  formula_sev,
  prior = mypriors_sev,
  stanvars = stanvar(scode = sev_functions, block = "functions"),
  data = severity_data, 
  backend = "cmdstan",
  threads = threading(12),
  control = list(adapt_delta = 0.99),
  max_treedepth=20,
  #seed = 1235,
  refresh = 100,
  iter = 5000, 
  #output_samples = 1000,
  warmup = 2500,
  thin = 1,
  init = 0,
  chains = 2, 
  cores = 12,
  silent=2,
  #algorithm = "fullrank" # this uses variational inference rather than mcmc
  )
```

# some validation 

# export functions
generate the necessary functions in r by exporting the stan model functions

```{r}
library(rstan) #making sure it is the one from CRAN, in this case 2.21.3 which is quite old but works for this
library(brms)
modelRstan_sev = brm(
  formula_sev,
  family = brmsfamily("gaussian",link = "identity",link_sigma = "identity"),
  prior = mypriors_sev,
  stanvars = stanvar(scode = sev_functions, block = "functions"),
  data = severity_data,
  backend = "rstan",# change to rstan to make use of "expose_functions()"
  chains = 0, # runs no iterations
  )
expose_functions(modelRstan_sev, vectorize = TRUE, cacheDir = "~/ULR-model")
```

#projections
do some projections out to t=134 for each year in each segment


```{r}


plot_data_sev = severity_data %>% 
  group_by(ReservingClass,year_segment)%>%
  complete(DevMth=(max(DevMth)+1):134)%>% 
  arrange(DevMth)%>%
  mutate(DevMthprev = lag(DevMth,lag=1, default = 0.1)
         ,YOA = first(YOA))%>%
  add_linpred_draws(model_sev,dpar=TRUE,ndraws=100)%>%
  group_by(ReservingClass,year_segment,.draw)%>%arrange(ReservingClass,year_segment,.draw,DevMth)%>%
  mutate(.prediction = rnorm(n(),mu,sigma))
  

```

# perform the plots for the projections

```{r}
library(plotly)
library(ggplot2)
library(patchwork)# allows for the side by side charting process that you see below


ACPC_plot = list()
plot_list = list()
plot_seg = list()
              
for (j in unique(as.numeric(severity_data$ReservingClass))){
selectedsegment=j

pred_increments <- plot_data_sev%>%filter(as.numeric(ReservingClass)==selectedsegment)
                         
        for (i in unique(pred_increments$YOA)){
          k=paste0("segment_",j,"_year_",i)
          ACPC_plot[[k]] = pred_increments%>%
                        filter(YOA ==i)%>%
                        group_by(ReservingClass,YOA,.draw)%>%
                        arrange(DevMth)%>%
                        mutate(N_predicted = cumsum(.prediction))%>%
                        ggplot(aes(x = DevMth, y = N_predicted)) +
                        stat_lineribbon() +
                        scale_fill_brewer() +
                        geom_point(data = pred_increments%>%filter(YOA ==(i),.draw==1), aes(DevMth, ACPC))
          
          if (i==min(pred_increments$YOA)){ 
            plot_seg = ACPC_plot[[k]] 
          }else{ 
              plot_seg = plot_seg + ACPC_plot[[k]]
              }
        }
plot_list[[paste0("segment_",j)]] = plot_seg

}
plot_list$segment_1
plot_list$segment_2
plot_list$segment_3
plot_list$segment_4
plot_list$segment_5
plot_list$segment_6
plot_list$segment_7
plot_list$segment_8


```