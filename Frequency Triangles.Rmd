---
title: "Claim Count Triangles"
author: "Cy Sonkkila"
date: '2022-03-24'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## working with claims triangles

we are now going to introduce a synthetic claims triangle, and then attempt to solve for some real(ish) data.

Using the methods developed in the introduction, we synthesize several years of data. Then cut off that data at various maturity levels, consistent with standard insurance claim development. In the case here where we are assuming monthly information and a maximum development time of something like 5 years, we will have examples where over a 10 year period the earliest years will have 120 months of development, but the most recent year might have only 12, or even no development data at all (i.e. a prediction for a policy year that has not incepted yet).

# The original family
```{r}
# nlp_Nnegincrement_Ubin[n] naming conventions
library(brms)
binomsharedpars <- custom_family(
                    "binomsharedpars", dpars = c("mu","mubin","sigmabin"), # actually mu is                really the Ubin for the binomial 
                    links = c("log","identity","log"),
                    type = "int",# lpmf vs lpdf
                    vars = c("vint1[n]", # Nprev
                             "vint2[n]", # N
                             "vreal1[n]",# t
                             "vreal2[n]",# tprev
                             "nlp_Nposincrement_Upois[n]", #Upois
                             "nlp_Nposincrement_mupois[n]", #mupois
                             "nlp_Nposincrement_sigmapois[n]" #sigmapois
                             ) 
              )
```

# A basic formula
```{r}
library(brms)
# writing the formula for the model making use of time and segmentation of the data
formula <-  bf(
   N_pos_increment ~ lambda,
   nlf(lambda ~ log(Upois) + logdifffunction(t,tprev,mupois,sigmapois) ) ,# std incremental poisson model for N+ using modified version of lccdf for syntax and numerical accuracy in the tail
   nlf(Upois ~ exp(Upoisstd*2+7)),
   mupois~ 0 + (1 + year+year^2|id|segment),
   Upoisstd ~0 + (1 + year+year^2|id|segment),
  nlf(sigmapois~exp(sigmapoisstd+1)),
  sigmapoisstd~0 + (1 + year+year^2|id|segment),
  family = poisson(),
  nl=TRUE)+
  bf(N_neg_increment | vint(Nprev,N)+vreal(t,tprev) ~ 0 + (1 + year+year^2|id2|segment) ,
     mubin~0 + (1 + year+year^2|id2|segment),
     sigmabin~0 + (1 + year+year^2|id2|segment),
     family = binomsharedpars)

# specify std normal non-centred priors
mypriors <- c(
  #prior(normal(0, 1),resp = "Nposincrement", nlpar = "Upoisstd"),
  #prior(normal(0, 1), resp = "Nnegincrement",dpar = "mu"),
  #prior(normal(0, 1), resp = "Nposincrement",nlpar = "sigmapoisstd"),
  #prior(normal(0, 1), class = "Intercept",resp = "Nnegincrement",dpar = "sigmabin"),
  #prior(normal(2, 2), resp = "Nposincrement",nlpar = "mupois"),
  #prior(normal(0, 1), class = "Intercept",resp = "Nnegincrement",dpar = "mubin")
  )
```

# The functions including error trapping
```{r}
stan_functions = "// we solve for #>0 at any point in time t  
vector N_ode(real t,//time
             vector N,// expected # of non-zero claims and expected # dropping to zero at time t. must be a vector so 2d. This is what is being solved for.
             real U,
             real U_p,
             real mu,
             real sigma,
             real mu_p,
             real sigma_p
             ) {
    vector[2] dNdt;
    dNdt[1] = exp(log_diff_exp(log(U)+lognormal_lpdf(t|mu,sigma),log(N[1])+log(U_p)+lognormal_lpdf(t|mu_p,sigma_p)));// cumulative # claims >0
    dNdt[2] = N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));
    print(dNdt[1],\" \",dNdt[2]);
    return dNdt;// cumulative # claims dropped back to zero
}
// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] N,  // both N and N_neg
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dNdt[2];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu_p = theta[5];
    real sigma_p = theta[6];
    
    dNdt[1] = U*exp(lognormal_lpdf(t|mu,sigma))-N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims >0
    dNdt[2] = N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims dropped back to zero
    return dNdt;
}

// Integrate ODE to solve for N at a point in time 
real N_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  real returnpar;
  
  // check gradients can be calculated
  N0[1] = U*exp(lognormal_lpdf(t|mu,sigma))-1.0*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims >0
    N0[2] = 1.0*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims dropped back to zero
  if(is_nan(N0[1])||is_nan(N0[2])) print(N0[1],\" \",N0[2]);
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0.0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,1];// returns N only
  return returnpar;
}

// Integrate ODE to solve for N- at a point in time
real N_neg_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  real returnpar;
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receive par as input
                         N0, // N and N- at t=0
                         0.0 , // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,2];// returns N- only
  return returnpar;
}

real binomsharedpars_lpmf(int Nnegincrement,
                          real Ubin,
                          real mubin,
                          real sigmabin,
                          int Nprev,
                          int N,
                          real t,
                          real tprev,
                          real Upois,
                          real mupois,
                          real sigmapois
                          ){
    real p;
    //p= Ubin*exp(log_diff_exp(lognormal_lccdf(tprev|mubin,sigmabin), lognormal_lccdf(t|mubin,sigmabin)));
    p=fmax(1e-20,N_int(t,Upois,Ubin,mupois,sigmapois,mubin,sigmabin));
    if(is_nan(p)==1){
      print(t,\" \",Upois,\" \",Ubin,\" \",mupois,\" \",sigmapois,\" \",mubin,\" \",sigmabin);
      p= 1e-20; //error trap for some extreme initial conditions
    } 
    //return binomial_lpmf(Nnegincrement | N+Nnegincrement, min([0.99,min([0.99, Ubin*exp(log_diff_exp(lognormal_lccdf(tprev|mubin,sigmabin), lognormal_lccdf(t|mubin,sigmabin)))])]) );
    return poisson_lpmf(N|p);

}


real lognormal_lccdf_mod(real a,real b,real c){
  return lognormal_lccdf(a|b,c);
}

real logdifffunction(real t,real tprev,real mu,real sigma){
  real lambda=log_diff_exp(lognormal_lccdf(tprev|mu,sigma), lognormal_lccdf(t|mu,sigma));
  if(is_nan(lambda)) {
    print(t,\" \",tprev,\" \",mu,\" \",sigma);
    lambda = -350;
  }
  return lambda;
}

"
```
Many of the error comments when stan is running will refer to the line of the code that gave the error. It is therefore useful to extract the stancode to inspect and identify the bug. In this case it was a data error that needed tracking down. Claims were being identified at t=0, which is not permitted by the structure of the model.

You can see the addition of print statements and the modification of the poisson lccdf function calls to include error trapping.

# A brms call 
```{r}

model_triangles = brm(
  formula,
  prior = mypriors,
  stanvars = stanvar(scode = stan_functions, block = "functions"),
  data = stan_data_multisegment, 
  backend = "cmdstan",
  #threads = threading(6),
  control = list(adapt_delta = 0.99),
  seed = 1234,
  refresh = 1,
  iter = 20, 
  init = 0,
  chains = 1, cores = 6
  #file = "frequencyCMDStan3.rds"
  )
```

# family definition 
We define the family such that there is only one loglikelihood calculation rather than two separate components in the formula.

Having trouble with the complexity so I have to move in smaller steps. This is to introduce a single loglikelihood statement into stan using a new family definition. This will allow for parallel execution of the code.

```{r}

library(brms)
sharedpars_test <- custom_family(
                    "sharedpars_test", dpars = c("mu","mubin","sigmabin","Upois","mupois","sigmapois"), # actually mu is really the Ubin for the binomial 
                    links = c("log","identity","log","identity","identity","log"),
                    type = "int",# lpmf vs lpdf
                    vars = c("vint1[n]", # Nprev
                             "vint2[n]", # N
                             "vreal1[n]",# t
                             "vreal2[n]"# tprev
                             ) 
              )
```

# A new formula
```{r}
library(brms)
# writing the formula for the model making use of time and segmentation of the data
formula <- bf(N_pos_increment | vint(Nprev,N)+vreal(t,tprev) ~ 0 + (1 + year+year^2|id2|segment) ,
     mubin~0 + (1 + year+year^2|id2|segment),
     sigmabin~0 + (1 + year+year^2|id2|segment),
     nlf(Upois ~ exp(Upoisstd*2+7)),
     mupois~ 0 + (1 + year+year^2|id|segment),
     Upoisstd ~0 + (1 + year+year^2|id|segment),
     nlf(sigmapois~exp(sigmapoisstd+1)),
     sigmapoisstd~0 + (1 + year+year^2|id|segment),
     family = sharedpars_test)

# specify std normal non-centred priors
mypriors <- c(
  #prior(normal(0, 1),resp = "Nposincrement", nlpar = "Upoisstd"),
  #prior(normal(0, 1), resp = "Nnegincrement",dpar = "mu"),
  #prior(normal(0, 1), resp = "Nposincrement",nlpar = "sigmapoisstd"),
  #prior(normal(0, 1), class = "Intercept",resp = "Nnegincrement",dpar = "sigmabin"),
  #prior(normal(2, 2), resp = "Nposincrement",nlpar = "mupois"),
  #prior(normal(0, 1), class = "Intercept",resp = "Nnegincrement",dpar = "mubin")
  )
```

# Modified functions
```{r}
stan_functions = "// we solve for #>0 at any point in time t  
vector N_ode(real t,//time
             vector N,// expected # of non-zero claims and expected # dropping to zero at time t. must be a vector so 2d. This is what is being solved for.
             real U,
             real U_p,
             real mu,
             real sigma,
             real mu_p,
             real sigma_p
             ) {
    vector[2] dNdt;
    dNdt[1] = exp(log_diff_exp(log(U)+lognormal_lpdf(t|mu,sigma),log(N[1])+log(U_p)+lognormal_lpdf(t|mu_p,sigma_p)));// cumulative # claims >0
    dNdt[2] = N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));
    print(dNdt[1],\" \",dNdt[2]);
    return dNdt;// cumulative # claims dropped back to zero
}
// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] N,  // both N and N_neg
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dNdt[2];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu_p = theta[5];
    real sigma_p = theta[6];
    
    dNdt[1] = U*exp(lognormal_lpdf(t|mu,sigma))-N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims >0
    dNdt[2] = N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims dropped back to zero
    return dNdt;
}

// Integrate ODE to solve for N at a point in time 
real N_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  real returnpar;
  
  // check gradients can be calculated
  N0[1] = U*exp(lognormal_lpdf(t|mu,sigma))-1.0*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims >0
    N0[2] = 1.0*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims dropped back to zero
  if(is_nan(N0[1])||is_nan(N0[2])) print(N0[1],\" \",N0[2]);
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0.0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,1];// returns N only
  return returnpar;
}

// Integrate ODE to solve for N- at a point in time
real N_neg_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  real returnpar;
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receive par as input
                         N0, // N and N- at t=0
                         0.0 , // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,2];// returns N- only
  return returnpar;
}

real logdifffunction(real t,real tprev,real mu,real sigma){
  real lambda=log_diff_exp(lognormal_lccdf(tprev|mu,sigma), lognormal_lccdf(t|mu,sigma));
  if(is_nan(lambda)) {
    print(t,\" \",tprev,\" \",mu,\" \",sigma);
    lambda = -350;
  }
  return lambda;
}

real sharedpars_test_lpmf(int Nposincrement,
                          real Ubin,
                          real mubin,
                          real sigmabin,
                          real Upois,
                          real mupois,
                          real sigmapois,
                          int Nprev,
                          int N,
                          real t,
                          real tprev
                          ){
    real p;
    //p= Ubin*exp(log_diff_exp(lognormal_lccdf(tprev|mubin,sigmabin), lognormal_lccdf(t|mubin,sigmabin)));
    p=fmax(1e-20,N_int(t,Upois,Ubin,mupois,sigmapois,mubin,sigmabin));
    if(is_nan(p)==1){
      print(t,\" \",Upois,\" \",Ubin,\" \",mupois,\" \",sigmapois,\" \",mubin,\" \",sigmabin);
      p= 1e-20; //error trap for some extreme initial conditions
    } 
    //return binomial_lpmf(Nnegincrement | N+Nnegincrement, min([0.99,min([0.99, Ubin*exp(log_diff_exp(lognormal_lccdf(tprev|mubin,sigmabin), lognormal_lccdf(t|mubin,sigmabin)))])]) );
    return poisson_lpmf(N|p) + poisson_lpmf(Nposincrement|exp(log(Upois) + logdifffunction(t,tprev,mupois,sigmapois)));

}


real lognormal_lccdf_mod(real a,real b,real c){
  return lognormal_lccdf(a|b,c);
}



"
```

# A matching brms call
```{r}

model_triangles_single_family = brm(
  formula,
  prior = mypriors,
  stanvars = stanvar(scode = stan_functions, block = "functions"),
  data = stan_data_multisegment, 
  backend = "cmdstan",
  threads = threading(6),
  control = list(adapt_delta = 0.99),
  seed = 1234,
  refresh = 1,
  iter = 20, 
  init = 0,
  chains = 1, cores = 6
  #file = "frequencyCMDStan3.rds"
  )
```

Now we have a version running with multithreading

# Adding support for exposure

```{r}

library(brms)
sharedpars_exposure <- custom_family(
                    "sharedpars_exposure", dpars = c("mu","mupois","sigmapois","Ubin","mubin","sigmabin"), # actually mu is really the Upois for the poisson 
                    links = c("log","identity","log","log","identity","log"),
                    type = "int",# lpmf vs lpdf
                    vars = c("vint1[n]", # Nprev
                             "vint2[n]", # N
                             "vreal1[n]",# t
                             "vreal2[n]",# tprev
                             "vreal3[n]"# exposure
                             ) 
              )
```
exposure is added to the vars section and in the matching formula below. THis allows the poisson base rate to be a strict multiplier of exposure if desired.

We also discover that exposure has accidentally been set to zero for one segment in one year. This year has to be removed from the data unfortunately.

# formula with exposure
The formula can now be made more versatile to account for trending in development patterns.

```{r}
library(brms)
# writing the formula for the model making use of time and segmentation of the data
formula_exposure <- bf(N_pos_increment | vint(Nprev,N)+vreal(t,tprev,exposure) ~ (1|segment)+(1|year_segment),
                                                                       mupois~   (1|segment)+(1|year_segment),
                                                                       sigmapois~(1|segment)+(1|year_segment),
                                                                       mubin~    (1|segment)+(1|year_segment),
                                                                       Ubin ~    (1|segment)+(1|year_segment) ,
                                                                       sigmabin~ (1|segment)+(1|year_segment),
     family = sharedpars_exposure)

# specify std normal non-centred priors
mypriors <- c(
  #prior(normal(0, 1), class = "Intercept",  dpar = "Ubin"),
  #prior(normal(0, 1), class = "Intercept"),
  #prior(normal(0, 1), class = "Intercept", dpar = "sigmabin"),
  #prior(normal(0, 1), class = "Intercept", dpar = "sigmapois"),
  prior(normal(-10, 5), class = "Intercept", dpar = "mupois")
  #prior(normal(0, 1), class = "Intercept", dpar = "mubin")
  )
```

# functions with exposure
```{r}
stan_functions_exposure = "// we solve for #>0 at any point in time t  

// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] N,  // both N and N_neg
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dNdt[2];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu_p = theta[5];
    real sigma_p = theta[6];
    
    dNdt[1] = U*exp(lognormal_lpdf(t|mu,sigma))-N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims >0
    dNdt[2] = N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims dropped back to zero
    return dNdt;
}

// Integrate ODE to solve for N at a point in time 
real N_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  real returnpar;
  
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0.0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,1];// returns N only
  return returnpar;
}

real logdifffunction(real t,real tprev,real mu,real sigma){
  real lambda=log_diff_exp(lognormal_lccdf(tprev|mu,sigma), lognormal_lccdf(t|mu,sigma));
  if(is_nan(lambda)) {
    print(t,\" \",tprev,\" \",mu,\" \",sigma);
    lambda = -350;
  }
  return lambda;
}

real sharedpars_exposure_lpmf(int Nposincrement,
                          real Upois,
                          real mupois,
                          real sigmapois,
                          real Ubin,
                          real mubin,
                          real sigmabin,
                          int Nprev,
                          int N,
                          real t,
                          real tprev,
                          real exposure
                          ){

    // transform development mu such that 99% development at 60 months of development mu = log(x)-2.3*sigma
    // 2.3 is the z-score for the 99th percentile, mu must be less than this figure to be at least 99% developed by month 60
    //mupois = log(60)-2.3*sigmapois-exp(mupois);
    //mubin = log(60)-2.3*sigmabin-exp(mubin);

    return poisson_lpmf(N|N_int(t,Upois*exposure*1e-7,Ubin,log(60)-2.3*sigmapois-exp(mupois),sigmapois,log(60)-2.3*sigmabin-exp(mubin),sigmabin)) + poisson_log_lpmf(Nposincrement|log(exposure) - log(1e7)+ log(Upois) + log_diff_exp(lognormal_lccdf(tprev|log(60)-2.3*sigmapois-exp(mupois),sigmapois), lognormal_lccdf(t|log(60)-2.3*sigmapois-exp(mupois),sigmapois)));

}


real lognormal_lccdf_mod(real a,real b,real c){
  return lognormal_lccdf(a|b,c);
}



"
```

# extract stancode
this is to aid in debugging
```{r}
library(brms)
#testbrms = brm(y~1,data=data.frame(y=rnorm(100,0,2)), backend = "cmdstan")
triangles_exposure_priors = get_prior(formula_exposure,stanvars = stanvar(scode = stan_functions_exposure, block = "functions"),data = stan_data_multisegment)

stancode_exposure = make_stancode(formula_exposure,
  prior = mypriors,
  stanvars = stanvar(scode = stan_functions_exposure, block = "functions"),
  data = stan_data_multisegment, 
  threads = threading(6),
  backend = "cmdstan")
```

# brms call with exposure 

```{r}
library(brms)
library(dplyr)
model_triangles_exposure = brm(
  formula_exposure,
  prior = mypriors,
  stanvars = stanvar(scode = stan_functions_exposure, block = "functions"),
  data = stan_data_multisegment%>%filter(year<8), 
  backend = "cmdstan",
  threads = threading(12),
  control = list(adapt_delta = 0.99),
  max_treedepth=12,
  seed = 1235,
  refresh = 1,
  iter = 100, 
  warmup = 50,
  init = 0,
  chains = 1, cores = 12,silent=2,
  #file = "frequencyCMDStan3.rds"
  )
```
Note the use of init=0 to quickly provide initial conditions of the model where you should have the ability for all the math to work. In extreme conditions some initialisation can cause the code to give errors because the suggested initial parameters are VERY large or VERY small. In the case of a large model where there are so many parameters, the chance of one parameter being an accidentally bad choice is much higher and can kill your model.

Debugging identified that there were two entries where claims had movements at or before t=0, which is not permitted in this model. There can not be any claims at t=0. Since these were only two spurious entries, they were removed. The model is now running, but may require some further tweaks.

Also noted is the fact that this code is onot parallelised, so not very efficient for implementation on a larger computer, which may well be required.

We will now modify the family definition to accommodate the requirements of parallel execution. The most notable of which is that there can only be one loglikelihood calculation due to the need to share parameters.

# expose functions

```{r}
# we need to recompile using rstan to expose the ODE functions to r so that we can use them to compute N(t)

library(rstan) #making sure it is the one from CRAN, in this case 2.21.3 which is quite old but works for this
library(brms)
modelRstan = brm(
  formula_exposure,
  prior = mypriors,
  stanvars = stanvar(scode = stan_functions_exposure, block = "functions"),
  data = stan_data_multisegment%>%filter(year<12), 
  backend = "rstan",# change to rstan to make use of "expose_functions()"
  chains = 0, # runs no iterations
  )
expose_functions(modelRstan, vectorize = TRUE, cacheDir = "~/ULR-model")
```
# sample posterior
now that we got that working, we move to getting a few samples from tidybayes

first define two functions to work with posterior predict that generate posterior draws from the two different predictions, N and N_pos.
```{r}
# first have to define the helper function to generate the posterior 

posterior_predict_sharedpars_exposure_N <- function(i, prep, ...) {
  # lambda = N_int(t,Upois,Ubin,mupois,sigmapois,mubin,sigmabin)
  # this is the current, most basic, approximate method for generating an estimate of N. 
  
  Upois <- brms::get_dpar(prep, "mu", i = i)
  mupois <- brms::get_dpar(prep, "mupois", i = i)
  sigmapois <- brms::get_dpar(prep, "sigmapois", i = i)
  mubin <- brms::get_dpar(prep, "mubin", i = i)
  sigmabin <- brms::get_dpar(prep, "sigmabin", i = i)
  Ubin <- brms::get_dpar(prep, "Ubin", i = i)
  t <- prep$data$vreal1[i] # vint(Nprev,N)+vreal(t,tprev)
  tprev <- prep$data$vreal2[i]
  exposure <- prep$data$vreal3[i]
  N_est = c()
  lambda = c()
  for (j in 1:prep$ndraws){
    N_est[j] = N_int(t,Upois[j]*exposure*1e-7,Ubin[j],log(60)-2.3*sigmapois[j]-exp(mupois[j]),sigmapois[j],log(60)-2.3*sigmabin[j]-exp(mubin[j]),sigmabin[j])
    lambda[j]= exp(log(exposure) - log(1e7)+ log(Upois[j]) +logdifffunction( t, tprev, log(60)-2.3*sigmapois[j]-exp(mupois[j]), sigmapois[j]))
  }
  
  rpois(prep$ndraws,N_est)# rpois(prep$ndraws,lambda))
}

posterior_predict_sharedpars_exposure_Npos <- function(i, prep, ...) {
  # lambda = N_int(t,Upois,Ubin,mupois,sigmapois,mubin,sigmabin)
  # this is the current, most basic, approximate method for generating an estimate of N. 
  
  Upois <- brms::get_dpar(prep, "mu", i = i)
  mupois <- brms::get_dpar(prep, "mupois", i = i)
  sigmapois <- brms::get_dpar(prep, "sigmapois", i = i)
  mubin <- brms::get_dpar(prep, "mubin", i = i)
  sigmabin <- brms::get_dpar(prep, "sigmabin", i = i)
  Ubin <- brms::get_dpar(prep, "Ubin", i = i)
  t <- prep$data$vreal1[i] # vint(Nprev,N)+vreal(t,tprev)
  tprev <- prep$data$vreal2[i]
  exposure <- prep$data$vreal3[i]
  N_est = c()
  lambda = c()
  for (j in 1:prep$ndraws){
    N_est[j] = N_int(t,Upois[j]*exposure*1e-7,Ubin[j],log(60)-2.3*sigmapois[j]-exp(mupois[j]),sigmapois[j],log(60)-2.3*sigmabin[j]-exp(mubin[j]),sigmabin[j])
    lambda[j]= exp(log(exposure) - log(1e7)+ log(Upois[j]) +logdifffunction( t, tprev, log(60)-2.3*sigmapois[j]-exp(mupois[j]), sigmapois[j]))
  }
  
  rpois(prep$ndraws,lambda)
}

```

now generate plots of the actual versus fitted for a selected year.

```{r}
library(tidybayes)
library(plotly)
library(ggplot2)
library(patchwork)# allows for the side by side charting process that you see below

selectedsegment=2
selectedyear =8

posterior_predict_sharedpars_exposure = posterior_predict_sharedpars_exposure_N
predN <- predicted_draws(model_triangles_exposure, newdata = stan_data_multisegment%>%filter(segment==selectedsegment,year ==selectedyear))

posterior_predict_sharedpars_exposure = posterior_predict_sharedpars_exposure_Npos
predNpos <- predicted_draws(model_triangles_exposure, newdata = stan_data_multisegment%>%filter(segment==selectedsegment,year ==selectedyear))

N_plot = predN%>%filter(segment==selectedsegment,year ==selectedyear)%>%
   ggplot(aes(x = t, y = .prediction)) +
  stat_lineribbon() +
  scale_fill_brewer() +
 geom_point(data = predN%>%filter(segment==selectedsegment,year ==selectedyear), aes(t, N))

N_pos_plot = predNpos%>%filter(segment==selectedsegment,year ==selectedyear)%>%
  group_by(.draw)%>%
  mutate(N_pos_cum_sample = cumsum(.prediction))%>%ungroup()%>%
   ggplot(aes(x = t, y = N_pos_cum_sample)) +
  stat_lineribbon() +
  scale_fill_brewer() +
 geom_point(data = stan_data_multisegment%>%filter(segment==selectedsegment,year ==selectedyear), aes(t, N_pos_cum))

N_plot + N_pos_plot
```
we note that recent years are failing for some reason. Lets check in more detail.

```{r}
library(brms)
library(dplyr)

model_triangles_exposure = brm(
  formula_exposure,
  prior = mypriors,
  stanvars = stanvar(scode = stan_functions_exposure, block = "functions"),
  data = stan_data_multisegment, 
  backend = "cmdstan",
  threads = threading(12),
  control = list(adapt_delta = 0.99),
  max_treedepth=12,
  seed = 1235,
  refresh = 1,
  iter = 100, 
  warmup = 50,
  init = 0,
  chains = 1, cores = 12,silent=2,
  #file = "frequencyCMDStan3.rds"
  )

model_library = list()

for (i in unique(stan_data_multisegment$year_segment)){
  model_library[i] = brm(
  formula_exposure,
  prior = mypriors,
  stanvars = stanvar(scode = stan_functions_exposure, block = "functions"),
  data = stan_data_multisegment%>%filter(year_segment==i), 
  backend = "cmdstan",
  threads = threading(12),
  control = list(adapt_delta = 0.99),
  max_treedepth=12,
  seed = 1235,
  refresh = 0,
  iter = 50, 
  warmup = 25,
  init = 0,
  chains = 1, cores = 12,silent=2,
  #file = "frequencyCMDStan3.rds"
  )
  
}

```
# some work to increase performance
remove unnecessary components of the ODE functions


```{r}
stan_functions_streamlined = "// we solve for #>0 at any point in time t  

// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] N,  //  N 
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dNdt[1];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu_p = theta[5];
    real sigma_p = theta[6];
    
    dNdt[1] = U*exp(lognormal_lpdf(t|mu,sigma))-N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims >0
    return dNdt;
}

// Integrate ODE to solve for N at a point in time 
real N_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[1];     // Initial values
  real par[6];  // Parameters
  real N[1, 1];   // ODE solution at time t
  real returnpar;
  
  // Set initial values. There should be no claims initially
  N0[1] = 0.0; //cannot be zero in this version as we use log N
  
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N  at t=0
                         0.0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-2, 1e-2, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,1];// returns N only
  return returnpar;
}

real logdifffunction(real t,real tprev,real mu,real sigma){
  real lambda=log_diff_exp(lognormal_lccdf(tprev|mu,sigma), lognormal_lccdf(t|mu,sigma));
  if(is_nan(lambda)) {
    print(t,\" \",tprev,\" \",mu,\" \",sigma);
    lambda = -350;
  }
  return lambda;
}

real sharedpars_exposure_lpmf(int Nposincrement,
                          real Upois,
                          real mupois,
                          real sigmapois,
                          real Ubin,
                          real mubin,
                          real sigmabin,
                          int Nprev,
                          int N,
                          real t,
                          real tprev,
                          real exposure
                          ){
    real lambda;
    // transform development mu such that 99% development at 60 months of development mu = log(x)-2.3*sigma
    // 2.3 is the z-score for the 99th percentile, mu must be less than this figure to be at least 99% developed by month 60
    //mupois = log(60)-2.3*sigmapois-exp(mupois);
    //mubin = log(60)-2.3*sigmabin-exp(mubin);
    lambda = N_int(t,Upois*exposure*1e-7,Ubin,log(60)-2.3*sigmapois-exp(mupois),sigmapois,log(60)-2.3*sigmabin-exp(mubin),sigmabin);
    lambda = log(1+exp(10.0*lambda))/10.0;//softplus on N so that it cannot be negative
    return poisson_lpmf(N|lambda) + poisson_log_lpmf(Nposincrement|log(exposure) - log(1e7)+ log(Upois) + log_diff_exp(lognormal_lccdf(tprev|log(60)-2.3*sigmapois-exp(mupois),sigmapois), lognormal_lccdf(t|log(60)-2.3*sigmapois-exp(mupois),sigmapois)));

}


real lognormal_lccdf_mod(real a,real b,real c){
  return lognormal_lccdf(a|b,c);
}



"
```

```{r}
library(brms)
library(dplyr)
model_triangles_streamlined = brm(
  formula_exposure,
  prior = mypriors,
  stanvars = stanvar(scode = stan_functions_streamlined, block = "functions"),
  data = stan_data_multisegment%>%filter(as.numeric(segment)==1), 
  backend = "cmdstan",
  threads = threading(12),
  control = list(adapt_delta = 0.99),
  max_treedepth=20,
  seed = 1234,
  refresh = 1,
  iter = 20, 
  warmup = 10,
  init = 0,
  chains = 1, cores = 12,silent=2
  #file = "frequencyCMDStan3.rds"
  )
```
# track down the divergent transitions

```{r}
library(bayesplot)
color_scheme_set("darkgray")
theme(axis.text.x = element_text(angle = 90))
mcmc_parcoord(model_triangles_streamlined, 
              np = nuts_params(model_triangles_streamlined),transform = function(x) {(x - mean(x)) / sd(x)},
              pars = vars(contains("sd_"))
              )+theme(axis.text.x = element_text(angle = 90))


```
# set up with binomial for the negative claim count
below we will attempt the alternative mathematical formulation using a binomial distribution

# functions for binomial
```{r}
stan_functions_binom = "// we solve for #>0 at any point in time t  

// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] N,  // both N and N_neg
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dNdt[2];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu_p = theta[5];
    real sigma_p = theta[6];
    
    
    dNdt[1] = U*exp(lognormal_lpdf(t|mu,sigma))-fmax(0.0,N[1])*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims >0
    dNdt[2] = fmax(0.0,N[1])*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims dropped back to zero
    return dNdt;
}

// Integrate ODE to solve for N at a point in time 
real N_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  real returnpar;
  
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0.0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,1];// returns N only
  return returnpar;
}

real logdifffunction(real t,real tprev,real mu,real sigma){
  real lambda=log_diff_exp(lognormal_lccdf(tprev|mu,sigma), lognormal_lccdf(t|mu,sigma));
  if(is_nan(lambda)) {
    print(t,\" \",tprev,\" \",mu,\" \",sigma);
    lambda = -350;
  }
  return lambda;
}

real sharedpars_exposure_lpmf(int Nposincrement,
                          real Upois,
                          real mupois,
                          real sigmapois,
                          real Ubin,
                          real mubin,
                          real sigmabin,
                          int Nprev,
                          int N,
                          real t,
                          real tprev,
                          real exposure
                          ){

  real N0[2];     // Initial values
  real par[6];  // Parameters
  real Nest[2, 2];   // ODE solution at time t and tprev
  real times[2]; 
  int Nnegincrement=Nprev-N+Nposincrement;
  
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  // transform development mu such that 99% development at 60 months of development mu = log(x)-2.3*sigma
  // 2.3 is the z-score for the 99th percentile, mu must be less than this figure 
  par[1] = Upois*exposure*1e-7;
  par[2] = Ubin;
  par[3] = log(60)-2.3*sigmapois-exp(mupois); 
  par[4] = sigmapois;
  par[5] = log(60)-2.3*sigmabin-exp(mubin); 
  par[6] = sigmabin;
  
  times[1]=tprev;
  times[2]=t;
  
  
  // Solve ODEs 
  Nest = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0.0, // initial t=0
                         times, //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-2, 1, 1e5); // % tolerance, absolute tolerance and max steps
 
  // binomial rate expressed as a percentage of the predicted Nprev 
  // (Nest[2,2]-Nest[1,2])/(0.5*(Nest[1,1]+Nest[2,1]))) or (expected Nnegincrement)/(average expected N to avoid inital condition errors)
  return binomial_lpmf(Nnegincrement|Nprev,fmin(0.99,(Nest[2,2]-Nest[1,2])/(0.5*(Nest[1,1]+Nest[2,1])))) + poisson_log_lpmf(Nposincrement|log(exposure) - log(1e7)+ log(Upois) + log_diff_exp(lognormal_lccdf(tprev|log(60)-2.3*sigmapois-exp(mupois),sigmapois), lognormal_lccdf(t|log(60)-2.3*sigmapois-exp(mupois),sigmapois)));

}


real lognormal_lccdf_mod(real a,real b,real c){
  return lognormal_lccdf(a|b,c);
}



"
```

# formula for binomial
```{r}
library(brms)
# writing the formula for the model making use of time and segmentation of the data
formula_binom <- bf(N_pos_increment | vint(Nprev,N)+vreal(t,tprev,exposure) ~ (1|segment)+(1|year_segment),
                                                                       mupois~   (1|segment)+(1|year_segment),
                                                                       sigmapois~(1|segment)+(1|year_segment),
                                                                       mubin~    (1|segment)+t2(t,bs=c("ts") ),
                                                                       Ubin ~    (1|segment)+t2(t,bs=c("ts") ) ,
                                                                       sigmabin~ (1|segment)+t2(t,bs=c("ts") ),
     family = sharedpars_exposure)

# specify std normal non-centred priors
mypriors_binom <- c(
  #prior(normal(0, 1), class = "Intercept",  dpar = "Ubin"),
  #prior(normal(0, 1), class = "Intercept"),
  #prior(normal(0, 1), class = "Intercept", dpar = "sigmabin"),
  #prior(normal(0, 1), class = "Intercept", dpar = "sigmapois"),
  prior(normal(-10, 5), class = "Intercept", dpar = "mupois")
  #prior(normal(0, 1), class = "Intercept", dpar = "mubin")
  )
```

# brms call using binomial
```{r}
library(brms)
library(dplyr)
model_triangles_binom_all_segments = brm(
  formula_binom,
  prior = mypriors_binom,
  stanvars = stanvar(scode = stan_functions_binom, block = "functions"),
  data = stan_data_multisegment, 
  backend = "cmdstan",
  threads = threading(12),
  control = list(adapt_delta = 0.99),
  max_treedepth=20,
  #seed = 1235,
  refresh = 1,
  iter = 50, 
  warmup = 30,
  init = 0,
  chains = 1, cores = 12,silent=2,
  #algorithm = "fullrank" # this uses variational inference rather than mcmc
  #file = "frequencyCMDStan3.rds"
  )
```


# Further tweaking of the functions for binomial
lets try to suggest that the poisson develops earlier and slower than the binomial i.e the mubin > mupoisson and sigmapoisson > sigmabin. This way the claim rejection process is contained to start developing later and develop at least as fast as the claim reserving process. 

This was observed to be of benefit early on in the development process to contain unrealistic initial conditions.

keeping these true no matter the initial conditions requires transforms to the parameters.

```{r}
stan_functions_binom_tweaked = "// we solve for #>0 at any point in time t  

// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] N,  // both N and N_neg
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dNdt[2];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu_p = theta[5];
    real sigma_p = theta[6];
    
    
    dNdt[1] = U*exp(lognormal_lpdf(t|mu,sigma))-fmax(0.0,N[1])*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims >0
    dNdt[2] = fmax(0.0,N[1])*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims dropped back to zero
    return dNdt;
}

// Integrate ODE to solve for N at a point in time 
real N_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  real returnpar;
  
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0.0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,1];// returns N only
  return returnpar;
}

real logdifffunction(real t,real tprev,real mu,real sigma){
  real lambda=log_diff_exp(lognormal_lccdf(tprev|mu,sigma), lognormal_lccdf(t|mu,sigma));
  if(is_nan(lambda)) {
    print(t,\" \",tprev,\" \",mu,\" \",sigma);
    lambda = -350;
  }
  return lambda;
}

real sharedpars_exposure_lpmf(int Nposincrement,
                          real Upois,
                          real mupois,
                          real sigmapois,
                          real Ubin,
                          real mubin,
                          real sigmabin,
                          int Nprev,
                          int N,
                          real t,
                          real tprev,
                          real exposure
                          ){

  real N0[2];     // Initial values
  real par[6];  // Parameters
  real Nest[2, 2];   // ODE solution at time t and tprev
  real times[2]; 
  int Nnegincrement=Nprev-N+Nposincrement;
  real p;
  
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  // transform development mu such that 99% development at 60 months of development mu = log(x)-2.3*sigma
  // 2.3 is the z-score for the 99th percentile, mu must be less than this figure 
  par[1] = Upois*exposure*1e-7;
  par[2] = Ubin;
  par[3] = log(60)-2.3*sigmapois-exp(mupois); 
  par[4] = sigmapois;
  par[5] = log(60)-2.3*sigmapois-exp(mupois)*inv_logit(mubin); // mubin > mupoisson
  par[6] = sigmapois*inv_logit(sigmabin); // sigmapois > sigmabin
  
  times[1]=tprev;
  times[2]=t;
 
  p = Ubin*exp(log_diff_exp(lognormal_lccdf(tprev|par[5],par[6]), lognormal_lccdf(t|par[5],par[6])));
  p = 1-log(1+exp(10.0-10.0*p))/10.0;// softplus method used such that p<1
  p = p*(1+(1-log(1+exp(10.0))/10.0))-1+log(1+exp(10.0))/10.0; // scale softplus such that p=0 -> p=0
  return binomial_lpmf(Nnegincrement|Nprev,p) + poisson_log_lpmf(Nposincrement|log(exposure) - log(1e7)+ log(Upois) + log_diff_exp(lognormal_lccdf(tprev|par[3],par[4]), lognormal_lccdf(t|par[3],par[4])));

}


real lognormal_lccdf_mod(real a,real b,real c){
  return lognormal_lccdf(a|b,c);
}



"
```

# brms call for the tweaked binomial functions
```{r}
library(brms)
library(dplyr)
model_triangles_binom_tweaked = brm(
  formula_binom,
  prior = mypriors_binom,
  stanvars = stanvar(scode = stan_functions_binom_tweaked, block = "functions"),
  data = stan_data_multisegment, 
  backend = "cmdstan",
  threads = threading(12),
  control = list(adapt_delta = 0.99),
  max_treedepth=20,
  #seed = 1235,
  refresh = 1,
  iter = 200, 
  #output_samples = 1000,
  warmup = 100,
  init = 0,
  chains = 1, 
  cores = 12,
  silent=2,
  #algorithm = "fullrank" # this uses variational inference rather than mcmc
  #file = "frequencyCMDStan3.rds"
  )
```
# functions for binomial with logspace ODE such that N cannot be <0

```{r}
stan_functions_binom_lnN = "// we solve for #>0 at any point in time t  

// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] lnN,  // both N and N_neg in log space
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dlnNdt[2];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu_p = theta[5];
    real sigma_p = theta[6];
    
    
    dlnNdt[1] = (U*exp(lognormal_lpdf(t|mu,sigma))-exp(lnN[1])*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p)))/exp(lnN[1]);// gradient of log cumulative # claims >0
    dlnNdt[2] = 0;// gradient of log cumulative # claims dropped back to zero
    //print(t,\" \",dlnNdt,\" \",theta,\" \",lnN);
    return dlnNdt;
}


real sharedpars_exposure_lpmf(int Nposincrement,
                          real Upois,
                          real mupois,
                          real sigmapois,
                          real Ubin,
                          real mubin,
                          real sigmabin,
                          int Nprev,
                          int N,
                          real t,
                          real tprev,
                          real exposure
                          ){

  real lnN0[2];     // Initial values
  real par[6];  // Parameters
  real lnNest[2, 2];   // ODE solution at time t and tprev
  real times[2]; 
  int Nnegincrement=Nprev-N+Nposincrement;
  real t0; // minimum time being considered
  
  
  // Set parameters
  // transform development mu such that 99% development at 60 months of development mu = log(x)-2.3*sigma
  // 2.3 is the z-score for the 99th percentile, mu must be less than this figure 
  par[1] = Upois*exposure*1e-7;
  par[2] = Ubin;
  par[3] = fmin(log(60)-2.3*sigmapois-exp(mupois),log(3)+2.3*sigmapois-exp(mupois)); 
  par[4] = sigmapois;
  par[5] = log(60)-2.3*sigmapois-exp(mupois)*inv_logit(mubin); // mubin > mupoisson
  par[6] = sigmapois*inv_logit(sigmabin); // sigmapois > sigmabin
  
  // set t0 such that the earlies time being considered is at 1% of development or higher
  t0 = exp(par[3]-2.3*par[4]);
  // Set initial values. There should be no claims initially, but we will derive expected N at t=1
  lnN0[1] = log(par[1])+lognormal_lcdf(t0|par[3],par[4]); 
  lnN0[2] = 0;
  
  times[1]=tprev;
  times[2]=t;
  
  
    // Solve ODEs 
    lnNest = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         lnN0, // N and N- at t=0
                         t0, // initial t=1 to avoid initial condition issues
                         times, //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-2, 1, 1e6); // % tolerance, absolute tolerance and max steps
  
 lnNest[1,1]=exp(lnNest[1,1]);
 lnNest[2,1]=exp(lnNest[2,1]);
 lnNest[1,2]= par[1]*exp(lognormal_lcdf(tprev|par[3],par[4]))-lnNest[1,1];
 lnNest[2,2]= par[1]*exp(lognormal_lcdf(t|par[3],par[4]))-lnNest[2,1];
 //print(t,\" \",exp(lnNest));
  // binomial rate expressed as a percentage of the predicted Nprev 
  // (Nest[2,2]-Nest[1,2])/(0.5*(Nest[1,1]+Nest[2,1]))) or (expected Nnegincrement)/(average expected N to avoid inital condition errors)
  return poisson_lpmf(Nnegincrement|fmax(1e-100,lnNest[2,2]-lnNest[1,2])) + poisson_log_lpmf(Nposincrement|log(par[1]) + log_diff_exp(lognormal_lccdf(tprev|par[3],par[4]), lognormal_lccdf(t|par[3],par[4])));
 

}


"
```

# brms call for binomial with lnN ODE

```{r}
library(brms)
library(dplyr)
model_triangles_binom_lnN = brm(
  formula_binom,
  prior = mypriors_binom,
  stanvars = stanvar(scode = stan_functions_binom_lnN, block = "functions"),
  data = stan_data_multisegment%>%filter(tprev>4), 
  backend = "cmdstan",
  threads = threading(12),
  control = list(adapt_delta = 0.99),
  max_treedepth=20,
  #seed = 1235,
  refresh = 1,
  iter = 60, 
  #output_samples = 1000,
  warmup = 30,
  init = 0,
  chains = 1, 
  cores = 12,
  silent=2,
  #algorithm = "fullrank" # this uses variational inference rather than mcmc
  #file = "frequencyCMDStan3.rds"
  )
```
# adding compression
Given the poor performance of this model. Particularly how slow it was running, I am inspired to look into data compression. In doing this I realised that claims in the tail are in regions where the expected frequency is low. In these regions, the variance is also low, so the likelihood distribution can be said to have high curvature. It has now become obvious to me that the data could easily be processed differently. It is likely a very good idea to group the reported claims into approximate deciles (or 20x5% groups). This would give no data points where the expected frequency was materially different to the others. This would reduce the possibility of high curvature in the model, possibly resulting in less divergent transitions and a faster model.

We will elect to group data into groups where approximately 5% of the development occurs.

lets make an assumption that most development is relatively similar, so that we can group years together for those years that have reached beyond 60 months of development.

See the sections in the data treatment code for the construction of the data we will now use.

# simple formula Poisson only for the positive claims
```{r}
library(brms)
formula_compressed = bf(N_group_increment ~ lambda + log(exposure),
   nlf(lambda ~ U + logdifffunction(t,tprev,log(60)-2.3*exp(sigmadev)-exp(mudev),exp(sigmadev)) ) ,# std incremental poisson model for N+ or N- using modified version of lccdf for syntax and numerical accuracy in the tail. adding development constraint as well
   mudev + U + sigmadev~ (1|id2|segment)+(1|id|year_segment),
  family = negbinomial(),
  nl=TRUE)


# specify std normal non-centred priors
mypriors_compressed <- c(
  prior(normal(0, 1),  nlpar = "U"),
  prior(normal(0, 1),  nlpar = "mudev"),
  prior(normal(0, 1),  nlpar = "sigmadev")
  )
```

# basic functions for compression
```{r}
stan_functions_compressed = "
real logdifffunction(real t,real tprev,real mu,real sigma){
  return log_diff_exp(lognormal_lccdf(tprev|mu,sigma), lognormal_lccdf(t|mu,sigma));
}

"
```

#check the stancode
confirming that the negative binomial implementation is using alternative parameters of the mean and the shape rather than alpha and beta.
```{r}
library(brms)
library(dplyr)
model_freq_compressed_stancode = make_stancode(
  formula_compressed,
  prior = mypriors_compressed,
  stanvars = stanvar(scode = stan_functions_compressed, block = "functions"),
  data = stan_data_compressed%>%
    filter(model=="N_pos_increment")%>%
    mutate(exposure = exposure*1e-7)
  )

```


# brms call for compressed model

```{r}
library(brms)
library(dplyr)
model_freq_compressed = brm(
  formula_compressed,
  prior = mypriors_compressed,
  stanvars = stanvar(scode = stan_functions_compressed, block = "functions"),
  data = stan_data_compressed%>%
    filter(model=="N_pos_increment")%>%
    mutate(exposure = exposure*1e-7), 
  backend = "cmdstan",
  threads = threading(12),
  control = list(adapt_delta = 0.99),
  max_treedepth=20,
  #seed = 1235,
  refresh = 50,
  iter = 500, 
  #output_samples = 1000,
  warmup = 250,
  init = 0,
  chains = 1, 
  cores = 12,
  silent=2,
  #algorithm = "fullrank" # this uses variational inference rather than mcmc
  #file = "frequencyCMDStan3.rds"
  )
```


this is two orders of magnitude faster than the previous model, and no divergences.

# simple formula Beta Binomial only for the negative claims
```{r}
library(brms)
formula_compressed_neg = bf(N_group_increment | trials(N+N_group_increment) ~ lambda ,
   nlf(lambda ~ U + logdifffunction(t,tprev,log(240)-2.3*exp(sigmadev)-exp(mudev),exp(sigmadev)) ) ,# std incremental model for N+ or N- using modified version of lccdf for syntax and numerical accuracy in the tail
   mudev + U + sigmadev~ (1|id2|segment)+(1|id|year_segment),
  family = beta_binomial,
  nl=TRUE)


# specify std normal non-centred priors
mypriors_compressed_neg <- c(
  prior(normal(0, 1),  nlpar = "U"),
  prior(normal(0, 1),  nlpar = "mudev"),
  prior(normal(0, 1),  nlpar = "sigmadev")
  )
```

#check the stancode
confirming that the negative binomial implementation is using alternative parameters of the mean and the shape rather than alpha and beta.
```{r}
library(brms)
library(dplyr)
model_freq_compressed_stancode_neg = make_stancode(
  formula_compressed_neg,
  prior = mypriors_compressed_neg,
  stanvars = stanvar(scode = stan_functions_compressed, block = "functions"),
  data = stan_data_compressed%>%
    filter(model=="N_neg_increment")
  )

```

#run the binomial model
this is the approximate binomial model. To run it more accurately, the ODE version would be required.
```{r}
library(brms)
library(dplyr)
model_freq_compressed_neg = brm(
  formula_compressed_neg,
  prior = mypriors_compressed_neg,
  stanvars = stanvar(scode = stan_functions_compressed, block = "functions"),
  data = stan_data_compressed%>%
    filter(model=="N_neg_increment"), 
  backend = "cmdstan",
  threads = threading(12),
  control = list(adapt_delta = 0.99),
  max_treedepth=20,
  #seed = 1235,
  refresh = 50,
  iter = 500, 
  #output_samples = 1000,
  warmup = 250,
  init = 0,
  chains = 1, 
  cores = 12,
  silent=2,
  #algorithm = "fullrank" # this uses variational inference rather than mcmc
  #file = "frequencyCMDStan3.rds"
  )
```


# check out the divergences
```{r}
library(bayesplot)
library(ggplot2)
color_scheme_set("gray")
mcmc_parcoord(model_freq_compressed_neg, 
              np = nuts_params(model_freq_compressed_neg),transform = function(x) {(x - mean(x)) / sd(x)},
              pars = vars(1:20)
              )+theme(axis.text.x = element_text(angle = 90))


```
the std dev of the mudev intercept can go to zero, causing divergences. try to  modify.


# compressed frequency family definition
the data is now stacked such that one column contains incremental changes in either the Npos or Nneg because the timescale compression varies between the two models. We must define a new family and loglikelihood calculation to accept this information.

```{r}

library(brms)
freq_compressed <- custom_family(
                    "freq_compressed", dpars = c("mu","lambdaneg","phineg"), # actually mu is really the lambdapos for the poisson 
                    links = c("identity","logit","log"),
                    type = "int",# lpmf vs lpdf
                    vars = c("vint1[n]", # Nprev
                             "vint2[n]", # N
                             "vint3[n]", # model flag where 1 = N_pos_increment
                             "vreal1[n]",# t
                             "vreal2[n]",# tprev
                             "vreal3[n]"# exposure
                             ) 
              )
```

# Combined formula for Poisson Binomial in the case of a single segment
```{r}
library(brms)
formula_compressed_combined = bf(N_group_increment | vint(Nprev,N,modelflag)+vreal(t,tprev,exposure) ~ lambdapos + log(exposure),
   nlf(lambdapos ~ Upos + logdifffunction(t,tprev,log(60)-2.3*exp(sigmapos)-exp(mupos),exp(sigmapos)) ) ,# std incremental poisson model for N+ using modified version of lccdf for syntax and numerical accuracy in the tail. Constrained mu for >99% development at t=120
   Upos ~ t2(year)+(1|year),
   mupos  + sigmapos ~ poly(year,2),
   nlf(lambdaneg ~ Uneg + logdifffunction(t,tprev,log(100)-2.3*exp(sigmaneg)-exp(muneg),exp(sigmaneg)) ) ,# same model for N- but binomial with additional delay on reports permitted=-==
   Uneg + muneg  + sigmaneg ~ 1,
   phineg~ 1,
  family = freq_compressed,
  nl=TRUE)


# specify std normal non-centred priors
mypriors_compressed_combined <- c(
  #prior(normal(0, 1),  nlpar = "Upos"),
  prior(normal(2, 1),  nlpar = "mupos"),
  prior(normal(0, 1),  nlpar = "sigmapos"),
  prior(normal(0, 1),  nlpar = "Uneg"),
  prior(normal(3, 1),  nlpar = "muneg"),
  prior(normal(0, 1),  nlpar = "sigmaneg")
  #prior(normal(0, 1),class="Intercept",  dpar = "phineg")
  )
```

# functions expanded for combined compression model
```{r}
stan_functions_compressed_combined = "
real logdifffunction(real t,real tprev,real mu,real sigma){
  return log_diff_exp(lognormal_lccdf(tprev|mu,sigma), lognormal_lccdf(t|mu,sigma));
}

real freq_compressed_lpmf(int Nincrement,
                          real lambdapos,
                          real mu,
                          real phi,
                          int Nprev,
                          int N,
                          int flag,
                          real t,
                          real tprev,
                          real exposure
                          ){
    return flag==0 ? beta_binomial_lpmf(Nincrement|N+Nincrement,mu * phi, (1 - mu) * phi) : poisson_log_lpmf(Nincrement|lambdapos);
// note the use of poisson_log_lpmf as it is more accurate and we use identity link for lambdapos
}

"
```

#run the combined model for each segment separately
this is still the approximate binomial model. To run it more accurately, the ODE version would be required.
```{r}
library(brms)
library(dplyr)
model_list = list()
for (i in unique((stan_data_compressed%>%filter(as.numeric(segment)>6))$segment)){
model_list$i = brm(
  formula_compressed_combined,
  prior = mypriors_compressed_combined,
  stanvars = stanvar(scode = stan_functions_compressed_combined, block = "functions"),
  data = stan_data_compressed%>%
    filter(segment==i)%>%
    mutate(exposure = exposure*1e-7,
           modelflag = (model=="N_pos_increment")*1),
  backend = "cmdstan",
  threads = threading(12),
  control = list(adapt_delta = 0.99),
  max_treedepth=20,
  #seed = 1235,
  refresh = 50,
  iter = 500, 
  #output_samples = 1000,
  warmup = 250,
  init = 0,
  chains = 1, 
  cores = 12,
  silent=2,
  #algorithm = "fullrank" # this uses variational inference rather than mcmc
  #file = "frequencyCMDStan3.rds"
  )
}
```

We identified that the constraint of 99% developed by 5 years was to stringent for some lines and it was relaxed back to 20 years. Much easier to fit the tails on the data now, and much fewer divergences in the longest tailed lines. We also found that relaxing this condition did not reduce the number of divergent transitions. Neither did conversion of the binomial model to beta binomial.

We currently assume that the poisson model for positive claim count is stable, but we have introduced an overdispersed poisson to check on whether this improves performance. Overdispersed poisson is performed by a Negative Binomial model. So we have upgraded the statistical approach to a 2 parameter model for positive and negative claim counts to separately control variance just in case overdispersion is required. It is easily reduced back if this becomes possible.

We have reduced back the complexity of the model

#run the combined model for all segments
this is still the approximate binomial model. To run it more accurately, the ODE version would be required.

first define the formula for all segments
```{r}
library(brms)
formula_compressed_combined_allseg = bf(N_group_increment | vint(Nprev,N,modelflag)+vreal(t,tprev,exposure) ~ lambdapos + log(exposure),
   nlf(lambdapos ~ Upos + logdifffunction(t,tprev,log(60)-2.3*exp(sigmapos)-exp(mupos),exp(sigmapos)) ) ,# std incremental poisson model for N+ using modified version of lccdf for syntax and numerical accuracy in the tail. Constrained mu for >99% development at t=120
   Upos ~ t2(year, by = segment)+(1|year_segment)+(1|segment),
   mupos  + sigmapos ~ (poly(year,2)|segment),
   nlf(lambdaneg ~ Uneg + logdifffunction(t,tprev,log(80)-2.3*exp(sigmaneg)-exp(muneg),exp(sigmaneg)) ) ,# same model for N- but binomial with additional delay on reports permitted=-==
   Uneg + muneg  + sigmaneg ~ (1|segment),
   phineg~ (1|segment),
  family = freq_compressed,
  nl=TRUE)


# specify std normal non-centred priors
mypriors_compressed_combined_allseg <- c(
  #prior(normal(0, 1),  nlpar = "Upos"),
  prior(normal(2, 1),  nlpar = "mupos"),
  prior(normal(0, 1),  nlpar = "sigmapos"),
  prior(normal(0, 1),  nlpar = "Uneg"),
  prior(normal(3, 1),  nlpar = "muneg"),
  prior(normal(0, 1),  nlpar = "sigmaneg")
  #prior(normal(0, 1),class="Intercept",  dpar = "phineg")
  )
```

then run brms for all segments at once
```{r}
library(brms)
library(dplyr)
model_triangles_compressed_combined_allseg= brm(
  formula_compressed_combined_allseg,
  prior = mypriors_compressed_combined_allseg,
  stanvars = stanvar(scode = stan_functions_compressed_combined, block = "functions"),
  data = stan_data_compressed%>%
    #filter(as.numeric(segment)<7)%>%
    mutate(exposure = exposure*1e-7,
           modelflag = (model=="N_pos_increment")*1),
  backend = "cmdstan",
  threads = threading(12),
  control = list(adapt_delta = 0.99),
  max_treedepth=20,
  #seed = 1235,
  refresh = 1,
  iter = 500, 
  #output_samples = 1000,
  warmup = 250,
  init = 0,
  chains = 1, 
  cores = 12,
  silent=2,
  #algorithm = "fullrank" # this uses variational inference rather than mcmc
  #file = "frequencyCMDStan3.rds"
  )

```
So, after a bug correction in the data and walking back the complexity. We arrive at a model that is now working without divergences.

# validation visualisations

