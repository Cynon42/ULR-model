---
title: "Claim Count Triangles"
author: "Cy Sonkkila"
date: '2022-03-24'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## working with claims triangles

we are now going to introduce a synthetic claims triangle, and then attempt to solve for some real(ish) data.

Using the methods developed in the introduction, we synthesize several years of data. Then cut off that data at various maturity levels, consistent with standard insurance claim development. In the case here where we are assuming monthly information and a maximum development time of something like 5 years, we will have examples where over a 10 year period the earliest years will have 120 months of development, but the most recent year might have only 12, or even no development data at all (i.e. a prediction for a policy year that has not incepted yet).

# The original family
```{r}
# nlp_Nnegincrement_Ubin[n] naming conventions
library(brms)
binomsharedpars <- custom_family(
                    "binomsharedpars", dpars = c("mu","mubin","sigmabin"), # actually mu is                really the Ubin for the binomial 
                    links = c("log","identity","log"),
                    type = "int",# lpmf vs lpdf
                    vars = c("vint1[n]", # Nprev
                             "vint2[n]", # N
                             "vreal1[n]",# t
                             "vreal2[n]",# tprev
                             "nlp_Nposincrement_Upois[n]", #Upois
                             "nlp_Nposincrement_mupois[n]", #mupois
                             "nlp_Nposincrement_sigmapois[n]" #sigmapois
                             ) 
              )
```

# A basic formula
```{r}
library(brms)
# writing the formula for the model making use of time and segmentation of the data
formula <-  bf(
   N_pos_increment ~ lambda,
   nlf(lambda ~ log(Upois) + logdifffunction(t,tprev,mupois,sigmapois) ) ,# std incremental poisson model for N+ using modified version of lccdf for syntax and numerical accuracy in the tail
   nlf(Upois ~ exp(Upoisstd*2+7)),
   mupois~ 0 + (1 + year+year^2|id|segment),
   Upoisstd ~0 + (1 + year+year^2|id|segment),
  nlf(sigmapois~exp(sigmapoisstd+1)),
  sigmapoisstd~0 + (1 + year+year^2|id|segment),
  family = poisson(),
  nl=TRUE)+
  bf(N_neg_increment | vint(Nprev,N)+vreal(t,tprev) ~ 0 + (1 + year+year^2|id2|segment) ,
     mubin~0 + (1 + year+year^2|id2|segment),
     sigmabin~0 + (1 + year+year^2|id2|segment),
     family = binomsharedpars)

# specify std normal non-centred priors
mypriors <- c(
  #prior(normal(0, 1),resp = "Nposincrement", nlpar = "Upoisstd"),
  #prior(normal(0, 1), resp = "Nnegincrement",dpar = "mu"),
  #prior(normal(0, 1), resp = "Nposincrement",nlpar = "sigmapoisstd"),
  #prior(normal(0, 1), class = "Intercept",resp = "Nnegincrement",dpar = "sigmabin"),
  #prior(normal(2, 2), resp = "Nposincrement",nlpar = "mupois"),
  #prior(normal(0, 1), class = "Intercept",resp = "Nnegincrement",dpar = "mubin")
  )
```

# The functions including error trapping
```{r}
stan_functions = "// we solve for #>0 at any point in time t  
vector N_ode(real t,//time
             vector N,// expected # of non-zero claims and expected # dropping to zero at time t. must be a vector so 2d. This is what is being solved for.
             real U,
             real U_p,
             real mu,
             real sigma,
             real mu_p,
             real sigma_p
             ) {
    vector[2] dNdt;
    dNdt[1] = exp(log_diff_exp(log(U)+lognormal_lpdf(t|mu,sigma),log(N[1])+log(U_p)+lognormal_lpdf(t|mu_p,sigma_p)));// cumulative # claims >0
    dNdt[2] = N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));
    print(dNdt[1],\" \",dNdt[2]);
    return dNdt;// cumulative # claims dropped back to zero
}
// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] N,  // both N and N_neg
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dNdt[2];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu_p = theta[5];
    real sigma_p = theta[6];
    
    dNdt[1] = U*exp(lognormal_lpdf(t|mu,sigma))-N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims >0
    dNdt[2] = N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims dropped back to zero
    return dNdt;
}

// Integrate ODE to solve for N at a point in time 
real N_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  real returnpar;
  
  // check gradients can be calculated
  N0[1] = U*exp(lognormal_lpdf(t|mu,sigma))-1.0*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims >0
    N0[2] = 1.0*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims dropped back to zero
  if(is_nan(N0[1])||is_nan(N0[2])) print(N0[1],\" \",N0[2]);
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0.0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,1];// returns N only
  return returnpar;
}

// Integrate ODE to solve for N- at a point in time
real N_neg_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  real returnpar;
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receive par as input
                         N0, // N and N- at t=0
                         0.0 , // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,2];// returns N- only
  return returnpar;
}

real binomsharedpars_lpmf(int Nnegincrement,
                          real Ubin,
                          real mubin,
                          real sigmabin,
                          int Nprev,
                          int N,
                          real t,
                          real tprev,
                          real Upois,
                          real mupois,
                          real sigmapois
                          ){
    real p;
    //p= Ubin*exp(log_diff_exp(lognormal_lccdf(tprev|mubin,sigmabin), lognormal_lccdf(t|mubin,sigmabin)));
    p=fmax(1e-20,N_int(t,Upois,Ubin,mupois,sigmapois,mubin,sigmabin));
    if(is_nan(p)==1){
      print(t,\" \",Upois,\" \",Ubin,\" \",mupois,\" \",sigmapois,\" \",mubin,\" \",sigmabin);
      p= 1e-20; //error trap for some extreme initial conditions
    } 
    //return binomial_lpmf(Nnegincrement | N+Nnegincrement, min([0.99,min([0.99, Ubin*exp(log_diff_exp(lognormal_lccdf(tprev|mubin,sigmabin), lognormal_lccdf(t|mubin,sigmabin)))])]) );
    return poisson_lpmf(N|p);

}


real lognormal_lccdf_mod(real a,real b,real c){
  return lognormal_lccdf(a|b,c);
}

real logdifffunction(real t,real tprev,real mu,real sigma){
  real lambda=log_diff_exp(lognormal_lccdf(tprev|mu,sigma), lognormal_lccdf(t|mu,sigma));
  if(is_nan(lambda)) {
    print(t,\" \",tprev,\" \",mu,\" \",sigma);
    lambda = -350;
  }
  return lambda;
}

"
```
Many of the error comments when stan is running will refer to the line of the code that gave the error. It is therefore useful to extract the stancode to inspect and identify the bug. In this case it was a data error that needed tracking down. Claims were being identified at t=0, which is not permitted by the structure of the model.

You can see the addition of print statements and the modification of the poisson lccdf function calls to include error trapping.

# A brms call 
```{r}

model_triangles = brm(
  formula,
  prior = mypriors,
  stanvars = stanvar(scode = stan_functions, block = "functions"),
  data = stan_data_multisegment, 
  backend = "cmdstan",
  #threads = threading(6),
  control = list(adapt_delta = 0.99),
  seed = 1234,
  refresh = 1,
  iter = 20, 
  init = 0,
  chains = 1, cores = 6
  #file = "frequencyCMDStan3.rds"
  )
```

# Introduce a new family such that there is only one loglikelihood

having trouble with the complexity so I have to move in smaller steps. This is to introduce a single loglikelihood statement into stan using a new family definition. This will allow for parallel execution of the code.

```{r}

library(brms)
sharedpars_test <- custom_family(
                    "sharedpars_test", dpars = c("mu","mubin","sigmabin","Upois","mupois","sigmapois"), # actually mu is really the Ubin for the binomial 
                    links = c("log","identity","log","identity","identity","log"),
                    type = "int",# lpmf vs lpdf
                    vars = c("vint1[n]", # Nprev
                             "vint2[n]", # N
                             "vreal1[n]",# t
                             "vreal2[n]"# tprev
                             ) 
              )
```

# A new formula
```{r}
library(brms)
# writing the formula for the model making use of time and segmentation of the data
formula <- bf(N_pos_increment | vint(Nprev,N)+vreal(t,tprev) ~ 0 + (1 + year+year^2|id2|segment) ,
     mubin~0 + (1 + year+year^2|id2|segment),
     sigmabin~0 + (1 + year+year^2|id2|segment),
     nlf(Upois ~ exp(Upoisstd*2+7)),
     mupois~ 0 + (1 + year+year^2|id|segment),
     Upoisstd ~0 + (1 + year+year^2|id|segment),
     nlf(sigmapois~exp(sigmapoisstd+1)),
     sigmapoisstd~0 + (1 + year+year^2|id|segment),
     family = sharedpars_test)

# specify std normal non-centred priors
mypriors <- c(
  #prior(normal(0, 1),resp = "Nposincrement", nlpar = "Upoisstd"),
  #prior(normal(0, 1), resp = "Nnegincrement",dpar = "mu"),
  #prior(normal(0, 1), resp = "Nposincrement",nlpar = "sigmapoisstd"),
  #prior(normal(0, 1), class = "Intercept",resp = "Nnegincrement",dpar = "sigmabin"),
  #prior(normal(2, 2), resp = "Nposincrement",nlpar = "mupois"),
  #prior(normal(0, 1), class = "Intercept",resp = "Nnegincrement",dpar = "mubin")
  )
```

# Modified functions
```{r}
stan_functions = "// we solve for #>0 at any point in time t  
vector N_ode(real t,//time
             vector N,// expected # of non-zero claims and expected # dropping to zero at time t. must be a vector so 2d. This is what is being solved for.
             real U,
             real U_p,
             real mu,
             real sigma,
             real mu_p,
             real sigma_p
             ) {
    vector[2] dNdt;
    dNdt[1] = exp(log_diff_exp(log(U)+lognormal_lpdf(t|mu,sigma),log(N[1])+log(U_p)+lognormal_lpdf(t|mu_p,sigma_p)));// cumulative # claims >0
    dNdt[2] = N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));
    print(dNdt[1],\" \",dNdt[2]);
    return dNdt;// cumulative # claims dropped back to zero
}
// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] N,  // both N and N_neg
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dNdt[2];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu_p = theta[5];
    real sigma_p = theta[6];
    
    dNdt[1] = U*exp(lognormal_lpdf(t|mu,sigma))-N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims >0
    dNdt[2] = N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims dropped back to zero
    return dNdt;
}

// Integrate ODE to solve for N at a point in time 
real N_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  real returnpar;
  
  // check gradients can be calculated
  N0[1] = U*exp(lognormal_lpdf(t|mu,sigma))-1.0*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims >0
    N0[2] = 1.0*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims dropped back to zero
  if(is_nan(N0[1])||is_nan(N0[2])) print(N0[1],\" \",N0[2]);
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0.0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,1];// returns N only
  return returnpar;
}

// Integrate ODE to solve for N- at a point in time
real N_neg_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  real returnpar;
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receive par as input
                         N0, // N and N- at t=0
                         0.0 , // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,2];// returns N- only
  return returnpar;
}

real logdifffunction(real t,real tprev,real mu,real sigma){
  real lambda=log_diff_exp(lognormal_lccdf(tprev|mu,sigma), lognormal_lccdf(t|mu,sigma));
  if(is_nan(lambda)) {
    print(t,\" \",tprev,\" \",mu,\" \",sigma);
    lambda = -350;
  }
  return lambda;
}

real sharedpars_test_lpmf(int Nposincrement,
                          real Ubin,
                          real mubin,
                          real sigmabin,
                          real Upois,
                          real mupois,
                          real sigmapois,
                          int Nprev,
                          int N,
                          real t,
                          real tprev
                          ){
    real p;
    //p= Ubin*exp(log_diff_exp(lognormal_lccdf(tprev|mubin,sigmabin), lognormal_lccdf(t|mubin,sigmabin)));
    p=fmax(1e-20,N_int(t,Upois,Ubin,mupois,sigmapois,mubin,sigmabin));
    if(is_nan(p)==1){
      print(t,\" \",Upois,\" \",Ubin,\" \",mupois,\" \",sigmapois,\" \",mubin,\" \",sigmabin);
      p= 1e-20; //error trap for some extreme initial conditions
    } 
    //return binomial_lpmf(Nnegincrement | N+Nnegincrement, min([0.99,min([0.99, Ubin*exp(log_diff_exp(lognormal_lccdf(tprev|mubin,sigmabin), lognormal_lccdf(t|mubin,sigmabin)))])]) );
    return poisson_lpmf(N|p) + poisson_lpmf(Nposincrement|exp(log(Upois) + logdifffunction(t,tprev,mupois,sigmapois)));

}


real lognormal_lccdf_mod(real a,real b,real c){
  return lognormal_lccdf(a|b,c);
}



"
```

# A matching brms call
```{r}

model_triangles_single_family = brm(
  formula,
  prior = mypriors,
  stanvars = stanvar(scode = stan_functions, block = "functions"),
  data = stan_data_multisegment, 
  backend = "cmdstan",
  threads = threading(6),
  control = list(adapt_delta = 0.99),
  seed = 1234,
  refresh = 1,
  iter = 20, 
  init = 0,
  chains = 1, cores = 6
  #file = "frequencyCMDStan3.rds"
  )
```

Now we have a version running with multithreading

# Adding support for exposure

```{r}

library(brms)
sharedpars_exposure <- custom_family(
                    "sharedpars_exposure", dpars = c("mu","mupois","sigmapois","Ubin","mubin","sigmabin"), # actually mu is really the Upois for the poisson 
                    links = c("log","identity","log","log","identity","log"),
                    type = "int",# lpmf vs lpdf
                    vars = c("vint1[n]", # Nprev
                             "vint2[n]", # N
                             "vreal1[n]",# t
                             "vreal2[n]",# tprev
                             "vreal3[n]"# exposure
                             ) 
              )
```
exposure is added to the vars section and in the matching formula below. THis allows the poisson base rate to be a strict multiplier of exposure if desired.

We also discover that exposure has accidentally been set to zero for one segment in one year. This year has to be removed from the data unfortunately.

# formula with exposure
The formula can now be made more versatile to account for trending in development patterns.

```{r}
library(brms)
# writing the formula for the model making use of time and segmentation of the data
formula_exposure <- bf(N_pos_increment | vint(Nprev,N)+vreal(t,tprev,exposure) ~ (1|segment)+(1|year_segment),
                                                                       mupois~   (1|segment)+(1|year_segment),
                                                                       sigmapois~(1|segment)+(1|year_segment),
                                                                       mubin~    (1|segment)+(1|year_segment),
                                                                       Ubin ~    (1|segment)+(1|year_segment) ,
                                                                       sigmabin~ (1|segment)+(1|year_segment),
     family = sharedpars_exposure)

# specify std normal non-centred priors
mypriors <- c(
  #prior(normal(0, 1), class = "Intercept",  dpar = "Ubin"),
  #prior(normal(0, 1), class = "Intercept"),
  #prior(normal(0, 1), class = "Intercept", dpar = "sigmabin"),
  #prior(normal(0, 1), class = "Intercept", dpar = "sigmapois"),
  prior(normal(-10, 5), class = "Intercept", dpar = "mupois")
  #prior(normal(0, 1), class = "Intercept", dpar = "mubin")
  )
```

# functions with exposure
```{r}
stan_functions_exposure = "// we solve for #>0 at any point in time t  

// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] N,  // both N and N_neg
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dNdt[2];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu_p = theta[5];
    real sigma_p = theta[6];
    
    dNdt[1] = U*exp(lognormal_lpdf(t|mu,sigma))-N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims >0
    dNdt[2] = N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims dropped back to zero
    return dNdt;
}

// Integrate ODE to solve for N at a point in time 
real N_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  real returnpar;
  
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0.0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,1];// returns N only
  return returnpar;
}

real logdifffunction(real t,real tprev,real mu,real sigma){
  real lambda=log_diff_exp(lognormal_lccdf(tprev|mu,sigma), lognormal_lccdf(t|mu,sigma));
  if(is_nan(lambda)) {
    print(t,\" \",tprev,\" \",mu,\" \",sigma);
    lambda = -350;
  }
  return lambda;
}

real sharedpars_exposure_lpmf(int Nposincrement,
                          real Upois,
                          real mupois,
                          real sigmapois,
                          real Ubin,
                          real mubin,
                          real sigmabin,
                          int Nprev,
                          int N,
                          real t,
                          real tprev,
                          real exposure
                          ){

    // transform development mu such that 99% development at 60 months of development mu = log(x)-2.3*sigma
    // 2.3 is the z-score for the 99th percentile, mu must be less than this figure to be at least 99% developed by month 60
    //mupois = log(60)-2.3*sigmapois-exp(mupois);
    //mubin = log(60)-2.3*sigmabin-exp(mubin);

    return poisson_lpmf(N|N_int(t,Upois*exposure*1e-7,Ubin,log(60)-2.3*sigmapois-exp(mupois),sigmapois,log(60)-2.3*sigmabin-exp(mubin),sigmabin)) + poisson_log_lpmf(Nposincrement|log(exposure) - log(1e7)+ log(Upois) + log_diff_exp(lognormal_lccdf(tprev|log(60)-2.3*sigmapois-exp(mupois),sigmapois), lognormal_lccdf(t|log(60)-2.3*sigmapois-exp(mupois),sigmapois)));

}


real lognormal_lccdf_mod(real a,real b,real c){
  return lognormal_lccdf(a|b,c);
}



"
```

# extract stancode
this is to aid in debugging
```{r}
library(brms)
#testbrms = brm(y~1,data=data.frame(y=rnorm(100,0,2)), backend = "cmdstan")
triangles_exposure_priors = get_prior(formula_exposure,stanvars = stanvar(scode = stan_functions_exposure, block = "functions"),data = stan_data_multisegment)

stancode_exposure = make_stancode(formula_exposure,
  prior = mypriors,
  stanvars = stanvar(scode = stan_functions_exposure, block = "functions"),
  data = stan_data_multisegment, 
  threads = threading(6),
  backend = "cmdstan")
```

# brms call with exposure 

```{r}
library(brms)
library(dplyr)
model_triangles_exposure = brm(
  formula_exposure,
  prior = mypriors,
  stanvars = stanvar(scode = stan_functions_exposure, block = "functions"),
  data = stan_data_multisegment%>%filter(year<8), 
  backend = "cmdstan",
  threads = threading(12),
  control = list(adapt_delta = 0.99),
  max_treedepth=12,
  seed = 1235,
  refresh = 1,
  iter = 100, 
  warmup = 50,
  init = 0,
  chains = 1, cores = 12,silent=2,
  #file = "frequencyCMDStan3.rds"
  )
```
Note the use of init=0 to quickly provide initial conditions of the model where you should have the ability for all the math to work. In extreme conditions some initialisation can cause the code to give errors because the suggested initial parameters are VERY large or VERY small. In the case of a large model where there are so many parameters, the chance of one parameter being an accidentally bad choice is much higher and can kill your model.

Debugging identified that there were two entries where claims had movements at or before t=0, which is not permitted in this model. There can not be any claims at t=0. Since these were only two spurious entries, they were removed. The model is now running, but may require some further tweaks.

Also noted is the fact that this code is onot parallelised, so not very efficient for implementation on a larger computer, which may well be required.

We will now modify the family definition to accommodate the requirements of parallel execution. The most notable of which is that there can only be one loglikelihood calculation due to the need to share parameters.

# expose functions

```{r}
# we need to recompile using rstan to expose the ODE functions to r so that we can use them to compute N(t)

library(rstan) #making sure it is the one from CRAN, in this case 2.21.3 which is quite old but works for this
library(brms)
modelRstan = brm(
  formula_exposure,
  prior = mypriors,
  stanvars = stanvar(scode = stan_functions_exposure, block = "functions"),
  data = stan_data_multisegment%>%filter(year<12), 
  backend = "rstan",# change to rstan to make use of "expose_functions()"
  chains = 0, # runs no iterations
  )
expose_functions(modelRstan, vectorize = TRUE, cacheDir = "~/ULR-model")
```
# sample posterior
now that we got that working, we move to getting a few samples from tidybayes

first define two functions to work with posterior predict that generate posterior draws from the two different predictions, N and N_pos.
```{r}
# first have to define the helper function to generate the posterior 

posterior_predict_sharedpars_exposure_N <- function(i, prep, ...) {
  # lambda = N_int(t,Upois,Ubin,mupois,sigmapois,mubin,sigmabin)
  # this is the current, most basic, approximate method for generating an estimate of N. 
  
  Upois <- brms::get_dpar(prep, "mu", i = i)
  mupois <- brms::get_dpar(prep, "mupois", i = i)
  sigmapois <- brms::get_dpar(prep, "sigmapois", i = i)
  mubin <- brms::get_dpar(prep, "mubin", i = i)
  sigmabin <- brms::get_dpar(prep, "sigmabin", i = i)
  Ubin <- brms::get_dpar(prep, "Ubin", i = i)
  t <- prep$data$vreal1[i] # vint(Nprev,N)+vreal(t,tprev)
  tprev <- prep$data$vreal2[i]
  exposure <- prep$data$vreal3[i]
  N_est = c()
  lambda = c()
  for (j in 1:prep$ndraws){
    N_est[j] = N_int(t,Upois[j]*exposure*1e-7,Ubin[j],log(60)-2.3*sigmapois[j]-exp(mupois[j]),sigmapois[j],log(60)-2.3*sigmabin[j]-exp(mubin[j]),sigmabin[j])
    lambda[j]= exp(log(exposure) - log(1e7)+ log(Upois[j]) +logdifffunction( t, tprev, log(60)-2.3*sigmapois[j]-exp(mupois[j]), sigmapois[j]))
  }
  
  rpois(prep$ndraws,N_est)# rpois(prep$ndraws,lambda))
}

posterior_predict_sharedpars_exposure_Npos <- function(i, prep, ...) {
  # lambda = N_int(t,Upois,Ubin,mupois,sigmapois,mubin,sigmabin)
  # this is the current, most basic, approximate method for generating an estimate of N. 
  
  Upois <- brms::get_dpar(prep, "mu", i = i)
  mupois <- brms::get_dpar(prep, "mupois", i = i)
  sigmapois <- brms::get_dpar(prep, "sigmapois", i = i)
  mubin <- brms::get_dpar(prep, "mubin", i = i)
  sigmabin <- brms::get_dpar(prep, "sigmabin", i = i)
  Ubin <- brms::get_dpar(prep, "Ubin", i = i)
  t <- prep$data$vreal1[i] # vint(Nprev,N)+vreal(t,tprev)
  tprev <- prep$data$vreal2[i]
  exposure <- prep$data$vreal3[i]
  N_est = c()
  lambda = c()
  for (j in 1:prep$ndraws){
    N_est[j] = N_int(t,Upois[j]*exposure*1e-7,Ubin[j],log(60)-2.3*sigmapois[j]-exp(mupois[j]),sigmapois[j],log(60)-2.3*sigmabin[j]-exp(mubin[j]),sigmabin[j])
    lambda[j]= exp(log(exposure) - log(1e7)+ log(Upois[j]) +logdifffunction( t, tprev, log(60)-2.3*sigmapois[j]-exp(mupois[j]), sigmapois[j]))
  }
  
  rpois(prep$ndraws,lambda)
}

```

now generate plots of the actual versus fitted for a selected year.

```{r}
library(tidybayes)
library(plotly)
library(ggplot2)
library(patchwork)# allows for the side by side charting process that you see below

selectedsegment=2
selectedyear =8

posterior_predict_sharedpars_exposure = posterior_predict_sharedpars_exposure_N
predN <- predicted_draws(model_triangles_exposure, newdata = stan_data_multisegment%>%filter(segment==selectedsegment,year ==selectedyear))

posterior_predict_sharedpars_exposure = posterior_predict_sharedpars_exposure_Npos
predNpos <- predicted_draws(model_triangles_exposure, newdata = stan_data_multisegment%>%filter(segment==selectedsegment,year ==selectedyear))

N_plot = predN%>%filter(segment==selectedsegment,year ==selectedyear)%>%
   ggplot(aes(x = t, y = .prediction)) +
  stat_lineribbon() +
  scale_fill_brewer() +
 geom_point(data = predN%>%filter(segment==selectedsegment,year ==selectedyear), aes(t, N))

N_pos_plot = predNpos%>%filter(segment==selectedsegment,year ==selectedyear)%>%
  group_by(.draw)%>%
  mutate(N_pos_cum_sample = cumsum(.prediction))%>%ungroup()%>%
   ggplot(aes(x = t, y = N_pos_cum_sample)) +
  stat_lineribbon() +
  scale_fill_brewer() +
 geom_point(data = stan_data_multisegment%>%filter(segment==selectedsegment,year ==selectedyear), aes(t, N_pos_cum))

N_plot + N_pos_plot
```
we note that recent years are failing for some reason. Lets check in more detail.

```{r}
library(brms)
library(dplyr)

model_triangles_exposure = brm(
  formula_exposure,
  prior = mypriors,
  stanvars = stanvar(scode = stan_functions_exposure, block = "functions"),
  data = stan_data_multisegment, 
  backend = "cmdstan",
  threads = threading(12),
  control = list(adapt_delta = 0.99),
  max_treedepth=12,
  seed = 1235,
  refresh = 1,
  iter = 100, 
  warmup = 50,
  init = 0,
  chains = 1, cores = 12,silent=2,
  #file = "frequencyCMDStan3.rds"
  )

model_library = list()

for (i in unique(stan_data_multisegment$year_segment)){
  model_library[i] = brm(
  formula_exposure,
  prior = mypriors,
  stanvars = stanvar(scode = stan_functions_exposure, block = "functions"),
  data = stan_data_multisegment%>%filter(year_segment==i), 
  backend = "cmdstan",
  threads = threading(12),
  control = list(adapt_delta = 0.99),
  max_treedepth=12,
  seed = 1235,
  refresh = 0,
  iter = 50, 
  warmup = 25,
  init = 0,
  chains = 1, cores = 12,silent=2,
  #file = "frequencyCMDStan3.rds"
  )
  
}

```
# some work to increase performance
remove unnecessary components of the ODE functions


```{r}
stan_functions_streamlined = "// we solve for #>0 at any point in time t  

// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] N,  //  N 
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dNdt[1];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu_p = theta[5];
    real sigma_p = theta[6];
    
    dNdt[1] = U*exp(lognormal_lpdf(t|mu,sigma))-N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims >0
    return dNdt;
}

// Integrate ODE to solve for N at a point in time 
real N_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[1];     // Initial values
  real par[6];  // Parameters
  real N[1, 1];   // ODE solution at time t
  real returnpar;
  
  // Set initial values. There should be no claims initially
  N0[1] = 0.0; //cannot be zero in this version as we use log N
  
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N  at t=0
                         0.0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-2, 1e-2, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,1];// returns N only
  return returnpar;
}

real logdifffunction(real t,real tprev,real mu,real sigma){
  real lambda=log_diff_exp(lognormal_lccdf(tprev|mu,sigma), lognormal_lccdf(t|mu,sigma));
  if(is_nan(lambda)) {
    print(t,\" \",tprev,\" \",mu,\" \",sigma);
    lambda = -350;
  }
  return lambda;
}

real sharedpars_exposure_lpmf(int Nposincrement,
                          real Upois,
                          real mupois,
                          real sigmapois,
                          real Ubin,
                          real mubin,
                          real sigmabin,
                          int Nprev,
                          int N,
                          real t,
                          real tprev,
                          real exposure
                          ){
    real lambda;
    // transform development mu such that 99% development at 60 months of development mu = log(x)-2.3*sigma
    // 2.3 is the z-score for the 99th percentile, mu must be less than this figure to be at least 99% developed by month 60
    //mupois = log(60)-2.3*sigmapois-exp(mupois);
    //mubin = log(60)-2.3*sigmabin-exp(mubin);
    lambda = N_int(t,Upois*exposure*1e-7,Ubin,log(60)-2.3*sigmapois-exp(mupois),sigmapois,log(60)-2.3*sigmabin-exp(mubin),sigmabin);
    lambda = log(1+exp(10.0*lambda))/10.0;//softplus on N so that it cannot be negative
    return poisson_lpmf(N|lambda) + poisson_log_lpmf(Nposincrement|log(exposure) - log(1e7)+ log(Upois) + log_diff_exp(lognormal_lccdf(tprev|log(60)-2.3*sigmapois-exp(mupois),sigmapois), lognormal_lccdf(t|log(60)-2.3*sigmapois-exp(mupois),sigmapois)));

}


real lognormal_lccdf_mod(real a,real b,real c){
  return lognormal_lccdf(a|b,c);
}



"
```

```{r}
library(brms)
library(dplyr)
model_triangles_streamlined = brm(
  formula_exposure,
  prior = mypriors,
  stanvars = stanvar(scode = stan_functions_streamlined, block = "functions"),
  data = stan_data_multisegment%>%filter(as.numeric(segment)==1), 
  backend = "cmdstan",
  threads = threading(12),
  control = list(adapt_delta = 0.99),
  max_treedepth=20,
  seed = 1234,
  refresh = 1,
  iter = 20, 
  warmup = 10,
  init = 0,
  chains = 1, cores = 12,silent=2
  #file = "frequencyCMDStan3.rds"
  )
```
# track down the divergent transitions

```{r}
library(bayesplot)
color_scheme_set("darkgray")
theme(axis.text.x = element_text(angle = 90))
mcmc_parcoord(model_triangles_streamlined, 
              np = nuts_params(model_triangles_streamlined),transform = function(x) {(x - mean(x)) / sd(x)},
              pars = vars(contains("sd_"))
              )+theme(axis.text.x = element_text(angle = 90))


```
# set up with binomial for the negative claim count
below we will attempt the alternative mathematical formulation using a binomial distribution

# functions for binomial
```{r}
stan_functions_binom = "// we solve for #>0 at any point in time t  

// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] N,  // both N and N_neg
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dNdt[2];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu_p = theta[5];
    real sigma_p = theta[6];
    
    
    dNdt[1] = U*exp(lognormal_lpdf(t|mu,sigma))-fmax(0.0,N[1])*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims >0
    dNdt[2] = fmax(0.0,N[1])*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims dropped back to zero
    return dNdt;
}

// Integrate ODE to solve for N at a point in time 
real N_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  real returnpar;
  
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0.0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,1];// returns N only
  return returnpar;
}

real logdifffunction(real t,real tprev,real mu,real sigma){
  real lambda=log_diff_exp(lognormal_lccdf(tprev|mu,sigma), lognormal_lccdf(t|mu,sigma));
  if(is_nan(lambda)) {
    print(t,\" \",tprev,\" \",mu,\" \",sigma);
    lambda = -350;
  }
  return lambda;
}

real sharedpars_exposure_lpmf(int Nposincrement,
                          real Upois,
                          real mupois,
                          real sigmapois,
                          real Ubin,
                          real mubin,
                          real sigmabin,
                          int Nprev,
                          int N,
                          real t,
                          real tprev,
                          real exposure
                          ){

  real N0[2];     // Initial values
  real par[6];  // Parameters
  real Nest[2, 2];   // ODE solution at time t and tprev
  real times[2]; 
  int Nnegincrement=Nprev-N+Nposincrement;
  
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  // transform development mu such that 99% development at 60 months of development mu = log(x)-2.3*sigma
  // 2.3 is the z-score for the 99th percentile, mu must be less than this figure 
  par[1] = Upois*exposure*1e-7;
  par[2] = Ubin;
  par[3] = log(60)-2.3*sigmapois-exp(mupois); 
  par[4] = sigmapois;
  par[5] = log(60)-2.3*sigmabin-exp(mubin); 
  par[6] = sigmabin;
  
  times[1]=tprev;
  times[2]=t;
  
  
  // Solve ODEs 
  Nest = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0.0, // initial t=0
                         times, //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-2, 1, 1e5); // % tolerance, absolute tolerance and max steps
 
  // binomial rate expressed as a percentage of the predicted Nprev 
  // (Nest[2,2]-Nest[1,2])/(0.5*(Nest[1,1]+Nest[2,1]))) or (expected Nnegincrement)/(average expected N to avoid inital condition errors)
  return binomial_lpmf(Nnegincrement|Nprev,fmin(0.99,(Nest[2,2]-Nest[1,2])/(0.5*(Nest[1,1]+Nest[2,1])))) + poisson_log_lpmf(Nposincrement|log(exposure) - log(1e7)+ log(Upois) + log_diff_exp(lognormal_lccdf(tprev|log(60)-2.3*sigmapois-exp(mupois),sigmapois), lognormal_lccdf(t|log(60)-2.3*sigmapois-exp(mupois),sigmapois)));

}


real lognormal_lccdf_mod(real a,real b,real c){
  return lognormal_lccdf(a|b,c);
}



"
```

# formula for binomial
```{r}
library(brms)
# writing the formula for the model making use of time and segmentation of the data
formula_binom <- bf(N_pos_increment | vint(Nprev,N)+vreal(t,tprev,exposure) ~ (1|segment)+(1|year_segment),
                                                                       mupois~   (1|segment)+(1|year_segment),
                                                                       sigmapois~(1|segment)+(1|year_segment),
                                                                       mubin~    (1|segment)+(1|year_segment),
                                                                       Ubin ~    (1|segment)+(1|year_segment) ,
                                                                       sigmabin~ (1|segment)+(1|year_segment),
     family = sharedpars_exposure)

# specify std normal non-centred priors
mypriors_binom <- c(
  #prior(normal(0, 1), class = "Intercept",  dpar = "Ubin"),
  #prior(normal(0, 1), class = "Intercept"),
  #prior(normal(0, 1), class = "Intercept", dpar = "sigmabin"),
  #prior(normal(0, 1), class = "Intercept", dpar = "sigmapois"),
  prior(normal(-10, 5), class = "Intercept", dpar = "mupois")
  #prior(normal(0, 1), class = "Intercept", dpar = "mubin")
  )
```

# brms call using binomial
```{r}
library(brms)
library(dplyr)
model_triangles_binom_all_segments = brm(
  formula_binom,
  prior = mypriors_binom,
  stanvars = stanvar(scode = stan_functions_binom, block = "functions"),
  data = stan_data_multisegment, 
  backend = "cmdstan",
  threads = threading(12),
  control = list(adapt_delta = 0.99),
  max_treedepth=20,
  #seed = 1235,
  refresh = 1,
  iter = 50, 
  warmup = 30,
  init = 0,
  chains = 1, cores = 12,silent=2,
  #algorithm = "fullrank" # this uses variational inference rather than mcmc
  #file = "frequencyCMDStan3.rds"
  )
```


# Further tweaking of the functions for binomial
lets try to suggest that the poisson develops earlier and slower than the binomial i.e the mubin > mupoisson and sigmapoisson > sigmabin. This way the claim rejection process is contained to start developing later and develop at least as fast as the claim reserving process. 

This was observed to be of benefit early on in the development process to contain unrealistic initial conditions.

keeping these true no matter the initial conditions requires transforms to the parameters.

```{r}
stan_functions_binom_tweaked = "// we solve for #>0 at any point in time t  

// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] N,  // both N and N_neg
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dNdt[2];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu_p = theta[5];
    real sigma_p = theta[6];
    
    
    dNdt[1] = U*exp(lognormal_lpdf(t|mu,sigma))-fmax(0.0,N[1])*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims >0
    dNdt[2] = fmax(0.0,N[1])*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims dropped back to zero
    return dNdt;
}

// Integrate ODE to solve for N at a point in time 
real N_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  real returnpar;
  
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0.0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,1];// returns N only
  return returnpar;
}

real logdifffunction(real t,real tprev,real mu,real sigma){
  real lambda=log_diff_exp(lognormal_lccdf(tprev|mu,sigma), lognormal_lccdf(t|mu,sigma));
  if(is_nan(lambda)) {
    print(t,\" \",tprev,\" \",mu,\" \",sigma);
    lambda = -350;
  }
  return lambda;
}

real sharedpars_exposure_lpmf(int Nposincrement,
                          real Upois,
                          real mupois,
                          real sigmapois,
                          real Ubin,
                          real mubin,
                          real sigmabin,
                          int Nprev,
                          int N,
                          real t,
                          real tprev,
                          real exposure
                          ){

  real N0[2];     // Initial values
  real par[6];  // Parameters
  real Nest[2, 2];   // ODE solution at time t and tprev
  real times[2]; 
  int Nnegincrement=Nprev-N+Nposincrement;
  real p;
  
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  // transform development mu such that 99% development at 60 months of development mu = log(x)-2.3*sigma
  // 2.3 is the z-score for the 99th percentile, mu must be less than this figure 
  par[1] = Upois*exposure*1e-7;
  par[2] = Ubin;
  par[3] = log(60)-2.3*sigmapois-exp(mupois); 
  par[4] = sigmapois;
  par[5] = log(60)-2.3*sigmapois-exp(mupois)*inv_logit(mubin); // mubin > mupoisson
  par[6] = sigmapois*inv_logit(sigmabin); // sigmapois > sigmabin
  
  times[1]=tprev;
  times[2]=t;
  
  
  // Solve ODEs 
  //print(t,\" \",tprev,\" \",par);
  Nest = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0.0, // initial t=0
                         times, //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-2, 1, 1e6); // % tolerance, absolute tolerance and max steps
 
  // binomial rate expressed as a percentage of the predicted Nprev 
  // (Nest[2,2]-Nest[1,2])/(0.5*(Nest[1,1]+Nest[2,1]))) or (expected Nnegincrement)/(average expected N to avoid inital condition errors)
  p = Ubin*exp(log_diff_exp(lognormal_lccdf(tprev|par[5],par[6]), lognormal_lccdf(t|par[5],par[6])));
  p = 1-log(1+exp(10.0-10.0*p))/10.0;
  return binomial_lpmf(Nnegincrement|Nprev,p) + poisson_log_lpmf(Nposincrement|log(exposure) - log(1e7)+ log(Upois) + log_diff_exp(lognormal_lccdf(tprev|par[3],par[4]), lognormal_lccdf(t|par[3],par[4])));

}


real lognormal_lccdf_mod(real a,real b,real c){
  return lognormal_lccdf(a|b,c);
}



"
```

# brms call for the tweaked binomial functions
```{r}
library(brms)
library(dplyr)
model_triangles_binom_tweaked = brm(
  formula_binom,
  prior = mypriors_binom,
  stanvars = stanvar(scode = stan_functions_binom_tweaked, block = "functions"),
  data = stan_data_multisegment%>%filter(t>2), 
  backend = "cmdstan",
  threads = threading(12),
  control = list(adapt_delta = 0.99),
  max_treedepth=20,
  #seed = 1235,
  refresh = 1,
  iter = 60, 
  #output_samples = 1000,
  warmup = 30,
  init = 0,
  chains = 1, 
  cores = 12,
  silent=2,
  #algorithm = "fullrank" # this uses variational inference rather than mcmc
  #file = "frequencyCMDStan3.rds"
  )
```
