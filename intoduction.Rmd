---
title: "ULR models"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Intro

here we try to combine a frequency and average ckaim size model into an incurred model. we observe that there is a rate at which claims are transitioning back to zero. our intention is to model net non-zero claims above some very low threshold.

```{r installbrms}
library(devtools)
remove.packages(c("StanHeaders", "rstan"))
##install_github("hsbadr/rstan/StanHeaders@develop")
install.packages("StanHeaders", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
install.packages("RcppEigen", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
#install_version("RcppEigen", "0.3.3.9.1")
##install_github("hsbadr/rstan/rstan/rstan@develop")
install.packages("rstan", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
install_github("paul-buerkner/brms",dependencies = TRUE)
```
## cmdstanr install

```{r installcmdstanr, echo = FALSE}

# this code chunk is made redundant by the installation of the github versions on BRMS and cmdstanr into the docker image.
# see the "Dockerfile"
install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
library(cmdstanr)
check_cmdstan_toolchain(fix=TRUE)
install_cmdstan(cores = 6,overwrite=TRUE)
cmdstan_path()
cmdstan_version()

file <- file.path(cmdstan_path(), "examples", "bernoulli", "bernoulli.stan")
mod <- cmdstan_model(file)

data_list <- list(N = 10, y = c(0,1,0,0,0,0,0,0,0,1))

# confirming models can run and run in parallel
fit <- mod$sample(
  data = data_list,
  iter_warmup = 1000,
  iter_sampling = 1e5,
  seed = 123,
  chains = 4,
  parallel_chains = 4,
  refresh = 1e4
)
```
## set cmdstan to build models in the background

```{r cmdstanparser}
library(cmdstanr)

register_knitr_engine()
```

## model development
after looking into the problem further, it might be smart to set it up as an ODE model first.

### example
the example below is from the stan documentation. the syntax of the functions has changed recently, making it harder to just use what in on the internet. A great example from the older syntax is from Marcus Gessman on mages blog [mages blog ](https://magesblog.com/post/2021-02-08-fitting-multivariate-ode-models-with-brms/).

```{stan, output.var="testmodel"}
functions {
  vector sho(real t,
             vector y,
             real theta) {
    vector[2] dydt;
    dydt[1] = y[2];
    dydt[2] = -y[1] - theta * y[2];
    return dydt;
  }
}
data {
  int<lower=1> T;
  vector[2] y0;
  real t0;
  array[T] real ts;
  real theta;
}
model {
}
generated quantities {
  vector[2] y_sim[T] = ode_rk45(sho, y0, t0, ts, theta);
  // add measurement error
  for (t in 1:T) {
    y_sim[t, 1] += normal_rng(0, 0.1);
    y_sim[t, 2] += normal_rng(0, 0.1);
  }
}
```


### my first try
I will try to get something working below.

#### some basic points
Start by just saying the the integral of the pdf is the lambda for any given time period, where the number of reported non-zero claims (excluding those that go back to zero) at any point in time is a poisson distribution with mean lambda. An analytic solution exists in terms of ult*lognormal_cdf(t,mu,sigma) where Ult is the ultimate expected number of claims that were ever positive.
$$\frac{\partial \lambda}{\partial t} = U.lognormal_{pdf}(t,\mu,\sigma)$$
the analytic solution is then $$\lambda(t) = U.lognormal_{cdf}(t,\mu,\sigma)$$ 

where $\lambda$ is the expected cumulative (i.e. current actual) number of non zero claims ever reported at a given point in time. When time is infinity the expected claim count is $U$ (the ultimate expected number). 

We will implement this as a standard poisson frequency model where we count the incremental number of reported non-nil claims.

Similarly, we can represent the binomial rate of non-zero claims falling back to zero. This is unfortunately required at times as we are modelling net claims and there can easily be a significant number of "negative IBNR" in the late tail of the claim count triangulations.
$$\frac{\partial p}{\partial t} = U_plognormal_{pdf}(t,\mu_p,\sigma_p)$$
Then we can show the analytic solution for p:$$p(t)=U_plognormal_{cdf}(t,\mu,\sigma)$$
but unfortunately: $$N_-(a)=\int_0^a\frac{\partial p}{\partial t}N(t) \partial t $$
With a binomial distribution, the calculation is harder. Now we introduce the count of claims and the expected count of claims for the number of positive reported claims $N_+(t)$, the number of claims that have fallen back to zero $N_-(t)$ and the current actual number of non-zero claims $N$.An alternative for $N_-$ might now be: $$\frac{\partial \overline N_-}{\partial t}=\overline N \frac {\partial p}{\partial t}$$
which is only true over many samples but is easier to solve for.
Then we can represent a differential equation perhaps: 
$$\frac{\partial \overline{N}_-}{\partial t} = \overline N(t).U_p.lognormal_{pdf}(t,\mu_p,\sigma_p)$$
which involves no discrete numbers. 

The first step of the process we can state more easily:
$$N_+(t)=poisson(\lambda(t))$$
A simple poisson sample. So $$\overline{N}_+(t)=\lambda(t)$$
A much easier calculation.

Calculating $N(t)$ seems the hardest. We shall approximate $\overline N(t)$ with a differential equation:$$\frac {\partial \overline N}{\partial t}=\frac {\partial \overline N_+}{\partial t} - \frac {\partial \overline N_-}{\partial t}$$
which simplifies to:$$\frac {\partial \overline N}{\partial t}=U.lognormal_{pdf}(t,\mu,\sigma) - \overline N(t).U_p.lognormal_{pdf}(t,\mu_p,\sigma_p)$$
which contains only continuous numbers and can be solved for in stan using the PDE solver or the numerical integrator.

#### start putting together a model

```{stan, output.var="odemodel", eval= false}

  // we solve for #>0 at any point in time t  
vector N_ode(real t,//time
             vector N,// expected # of non-zero claims and expected # dropping to zero at time t. must be a vector so 2d. This is what is being solved for.
             real U,
             real U_p,
             real mu,
             real sigma,
             real mu_p,
             real sigma_p
             ) {
    vector[2] dNdt;
    dNdt[1] = U*lognormal_lpdf(t|mu,sigma)-N[1]*U_p*lognormal_lpdf(t|mu_p,sigma_p);// cumulative # claims >0
    dNdt[2] = N[1]*U_p*lognormal_lpdf(t|mu_p,sigma_p);
    return dNdt;// cumulative # claims dropped back to zero
}
// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] N,  // both N and N_neg
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dNdt[2];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu = theta[5];
    real sigma_p = theta[6];
    
    dNdt[1] = U*lognormal_lpdf(t|mu,sigma)-N[1]*U_p*lognormal_lpdf(t|mu_p,sigma_p);// cumulative # claims >0
    dNdt[2] = N[1]*U_p*lognormal_lpdf(t|mu_p,sigma_p);// cumulative # claims dropped back to zero
    return dNdt;
}

// Integrate ODE to solve for N at a point in time
real N_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  return N[1];// returns N only
}

// Integrate ODE to solve for N- at a point in time
real N_neg_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  return N[2];// returns N- only
}

```
put this code into a text string and set up a brms formula
```{r}
library(brms)
functions = "// we solve for #>0 at any point in time t  
vector N_ode(real t,//time
             vector N,// expected # of non-zero claims and expected # dropping to zero at time t. must be a vector so 2d. This is what is being solved for.
             real U,
             real U_p,
             real mu,
             real sigma,
             real mu_p,
             real sigma_p
             ) {
    vector[2] dNdt;
    dNdt[1] = U*lognormal_lpdf(t|mu,sigma)-N[1]*U_p*lognormal_lpdf(t|mu_p,sigma_p);// cumulative # claims >0
    dNdt[2] = N[1]*U_p*lognormal_lpdf(t|mu_p,sigma_p);
    return dNdt;// cumulative # claims dropped back to zero
}
// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] N,  // both N and N_neg
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dNdt[2];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu = theta[5];
    real sigma_p = theta[6];
    
    dNdt[1] = U*lognormal_lpdf(t|mu,sigma)-N[1]*U_p*lognormal_lpdf(t|mu_p,sigma_p);// cumulative # claims >0
    dNdt[2] = N[1]*U_p*lognormal_lpdf(t|mu_p,sigma_p);// cumulative # claims dropped back to zero
    return dNdt;
}

// Integrate ODE to solve for N at a point in time
real N_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  return N[1];// returns N only
}

// Integrate ODE to solve for N- at a point in time
real N_neg_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  return N[2];// returns N- only
}

real lognormal_lccdf_mod(real a,real b,real c){
  return lognormal_lccdf(a|b,c);
}

"

# writing the formula we are essentially declaring what the parameters need to be called
formula <-  bf(
   N_pos_increment ~ lambda,
   nlf(lambda ~ log(Upois) +log_diff_exp( lognormal_lccdf_mod(tprev,mupois,sigmapois), lognormal_lccdf_mod(t,mupois,sigmapois)) ),# std incremental poisson model for N+ using modified version of lccdf for syntax and numerical accuracy in the tail
   nlf(Upois ~ exp(Upoisstd)),
   mupois~1,
   Upoisstd ~1,
  nlf(sigmapois~exp(sigmapoisstd)),
  sigmapoisstd~1,
  family = poisson(),
  nl=TRUE)+
  bf(N_neg_increment | vint(Nprev) ~ pbinom , nlf(pbinom~(N_neg_int(t,Upois,Ubin,mupois,sigmapois,mubin,sigmabin)-N_neg_int(tprev,Upois,Ubin,mupois,sigmapois,mubin,sigmabin))/N_int(tprev,Upois,Ubin,mupois,sigmapois,mubin,sigmabin)),# approximation based on available data
  # unfortunately the line above doesn't work as parameters cannot be shared between the poisson and binomial model within the brms syntax. so we must add it manually unfortunately
     nlf(Ubin~exp(Ubinstd)),
  nlf(sigmabin~exp(sigmabinstd)),
  mubin~1,
  Ubinstd~1,
  sigmabinstd~1,
  nlf(Upois ~ exp(Upoisstd)),
  mupois~1,
  Upoisstd ~1,
  nlf(sigmapois~exp(sigmapoisstd)),
  sigmapoisstd~1,
  family = binomial("identity"),
  nl = TRUE )

# specify std normal non-centred priors
mypriors <- c(
  prior(normal(0, 1),resp = "Nposincrement", nlpar = "Upoisstd"),
  prior(normal(0, 1), resp = "Nnegincrement",nlpar = "Ubinstd"),
  prior(normal(0, 1), resp = "Nposincrement",nlpar = "sigmapoisstd"),
  prior(normal(0, 1), resp = "Nnegincrement",nlpar = "sigmabinstd"),
  prior(normal(0, 1), resp = "Nposincrement",nlpar = "mupois"),
  prior(normal(0, 1), resp = "Nnegincrement",nlpar = "mubin"))
```

#### generate some data
I try never to use real data initially as I need to confirm that the models can recover parameters as expected and that the synthetic data can be contrived to look like the real world data.

```{r}
library(dplyr)
nt = 50 #number of time points
Upois = 50 # expected ultimate number of claims
# trial and error with parameters to get the performance of interest
mupois=2
sigmapois =1
Ubin = 2
mubin = 2.5
sigmabin=0.8
k=10
standata = data.frame(row = 1:nt,t=1:nt,
                      tprev = (1:nt) -1)%>%
                      #N_pos_increment ~ log(Upois) +log_diff_exp( lognormal_lccdf(tprev,mupois,sigmapois), lognormal_lccdf(t,mupois,sigmapois))
            mutate(
                      N_pos_increment = rpois(nt,exp(log(Upois) +log( x = 
                                                                                                                  plnorm(t,mupois,sigmapois)-
                                                                                                                  plnorm(tprev,mupois,sigmapois)))),
                      pois_cdf = plnorm(t,mupois,sigmapois),
                      bin_cdf = plnorm(t,mubin,sigmabin),
                      
                        #N_neg_increment | trials(Nprev) ~ (N_neg_int(t,Upois,Ubin,mupois,sigmapois,mubin,sigmabin)-N_neg_int(tprev,Upois,Ubin,mupois,sigmapois,mubin,sigmabin))/N_int(tprev,Upois,Ubin,mupois,sigmapois,mubin,sigmabin)
                      p_bin = Ubin*(plnorm(t,mubin,sigmabin)- plnorm(tprev,mubin,sigmabin)),
                      p_bin_softp = -(log(1+exp(-k*(p_bin-1)))/k -1)
                      
            )
for (i in 1:nt){
  standata$N_pos[i] = if(i != 1)  standata$N_pos_increment[i]+standata$N_pos[i-1] else standata$N_pos_increment[i]
  standata$N_neg_increment[i]= if(i != 1)  rbinom(1,standata$N[i-1],standata$p_bin_softp[i]) else 0
  standata$N_neg[i]= if(i != 1)  standata$N_neg_increment[i] +standata$N_neg[i-1] else standata$N_neg_increment[i]
  standata$N[i] = if(i != 1)  standata$N_pos_increment[i]-standata$N_neg_increment[i]+standata$N[i-1] else standata$N_pos_increment[i]-standata$N_neg_increment[i]
  standata$Nprev[i] = if(i != 1)  standata$N[i-1] else 0
}
standata$tprev[1]=0.01 # fix an initial conditions problem
```

####run the model
```{r}
prior_set = get_prior(formula,prior = mypriors, 
  stanvars = stanvar(scode = functions, block = "functions"),
  data = standata, backend = "cmdstan")

model <- brm(
  formula,prior = mypriors, 
  stanvars = stanvar(scode = functions, block = "functions"),
  data = standata, backend = "cmdstan",
  control = list(adapt_delta = 0.99),
  seed = 1234, iter = 1000, 
  chains = 4, cores = 6,
  file = "frequencyCMDStan.rds")
```
ok. it turns out that there is no easy way to share the poisson model parameters with the binomial model in a way that I can see without modifying the stan code directly...

Easiest way is to write my own family for the binomial section that pulls in the other shared parameters.
```{r}
# nlp_Nnegincrement_Ubin[n] naming conventions

binomsharedpars <- custom_family(
                    "binomsharedpars", dpars = c("mu","mubin","sigmabin"), # actually mu is                really the Ubin for the binomial 
                    links = c("log","identity","log"),
                    type = "int",# lpmf vs lpdf
                    vars = c("vint1[n]", # Nprev that we are passing as additional data
                             "vreal1[n]",# t
                             "vreal2[n]",# tprev
                             "nlp_Nposincrement_Upois[n]", #Upois
                             "nlp_Nposincrement_mupois[n]", #mupois
                             "nlp_Nposincrement_sigmapois[n]" #sigmapois
                             ) # the additional parameters to calculate                   pbinom~(N_neg_int(t,Upois,Ubin,mupois,sigmapois,mubin,sigmabin)-N_neg_int(                tprev,Upois,Ubin,mupois,sigmapois,mubin,sigmabin))/N_int(tprev,Upois,Ubin,               mupois,sigmapois,mubin,sigmabin)
              )
```

now we need to modify the functions section further to include the required functions to calculate the loglikelihood for the new family

```{stan,eval=false,echo=false}
// we solve for #>0 at any point in time t  
vector N_ode(real t,//time
             vector N,// expected # of non-zero claims and expected # dropping to zero at time t. must be a vector so 2d. This is what is being solved for.
             real U,
             real U_p,
             real mu,
             real sigma,
             real mu_p,
             real sigma_p
             ) {
    vector[2] dNdt;
    dNdt[1] = U*lognormal_lpdf(t|mu,sigma)-N[1]*U_p*lognormal_lpdf(t|mu_p,sigma_p);// cumulative # claims >0
    dNdt[2] = N[1]*U_p*lognormal_lpdf(t|mu_p,sigma_p);
    return dNdt;// cumulative # claims dropped back to zero
}
// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] N,  // both N and N_neg
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dNdt[2];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu = theta[5];
    real sigma_p = theta[6];
    
    dNdt[1] = U*lognormal_lpdf(t|mu,sigma)-N[1]*U_p*lognormal_lpdf(t|mu_p,sigma_p);// cumulative # claims >0
    dNdt[2] = N[1]*U_p*lognormal_lpdf(t|mu_p,sigma_p);// cumulative # claims dropped back to zero
    return dNdt;
}

// Integrate ODE to solve for N at a point in time
real N_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  return N[1];// returns N only
}

// Integrate ODE to solve for N- at a point in time
real N_neg_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0.0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  return N[2];// returns N- only
}

real binomsharedpars_lpmf(int Nnegincrement,
                          real Ubin,
                          real mubin,
                          real sigmabin,
                          int Nprev, 
                          real t,
                          real tprev,
                          real Upois,
                          real mupois,
                          real sigmapois,
                          ){
    return binomial_lpmf(Nnegincrement | Nprev,(N_neg_int(t,Upois,Ubin,mupois,sigmapois,mubin,sigmabin)-N_neg_int(tprev,Upois,Ubin,mupois,sigmapois,mubin,sigmabin))/N_int(tprev,Upois,Ubin,mupois,sigmapois,mubin,sigmabin));
}


real lognormal_lccdf_mod(real a,real b,real c){
  return lognormal_lccdf(a|b,c);
}
                         
```
use this as our stanvars for the functions section
```{r}
stan_functions = "// we solve for #>0 at any point in time t  
vector N_ode(real t,//time
             vector N,// expected # of non-zero claims and expected # dropping to zero at time t. must be a vector so 2d. This is what is being solved for.
             real U,
             real U_p,
             real mu,
             real sigma,
             real mu_p,
             real sigma_p
             ) {
    vector[2] dNdt;
    dNdt[1] = U*lognormal_lpdf(t|mu,sigma)-N[1]*U_p*lognormal_lpdf(t|mu_p,sigma_p);// cumulative # claims >0
    dNdt[2] = N[1]*U_p*lognormal_lpdf(t|mu_p,sigma_p);
    return dNdt;// cumulative # claims dropped back to zero
}
// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] N,  // both N and N_neg
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dNdt[2];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu_p = theta[5];
    real sigma_p = theta[6];
    
    dNdt[1] = U*lognormal_lpdf(t|mu,sigma)-N[1]*U_p*lognormal_lpdf(t|mu_p,sigma_p);// cumulative # claims >0
    dNdt[2] = N[1]*U_p*lognormal_lpdf(t|mu_p,sigma_p);// cumulative # claims dropped back to zero
    return dNdt;
}

// Integrate ODE to solve for N at a point in time
real N_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  real returnpar;
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0.0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,1];// returns N only
  return returnpar;
}

// Integrate ODE to solve for N- at a point in time
real N_neg_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  real returnpar;
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0.0 , // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,2];// returns N- only
  return returnpar;
}

real binomsharedpars_lpmf(int Nnegincrement,
                          real Ubin,
                          real mubin,
                          real sigmabin,
                          int Nprev, 
                          real t,
                          real tprev,
                          real Upois,
                          real mupois,
                          real sigmapois
                          ){
    real p;
    p=(N_neg_int(t,Upois,Ubin,mupois,sigmapois,mubin,sigmabin)-N_neg_int(tprev,Upois,Ubin,mupois,sigmapois,mubin,sigmabin))/N_int(tprev,Upois,Ubin,mupois,sigmapois,mubin,sigmabin);
    p = -(log(1+exp(-10*(p-1)))/10 -1);// use softplus to block approach to 1
    return binomial_lpmf(Nnegincrement | Nprev,p);
}


real lognormal_lccdf_mod(real a,real b,real c){
  return lognormal_lccdf(a|b,c);
}

"
```

now we are ready to try to build the brms model again

```{r}
# writing the formula we are essentially declaring what the parameters need to be called
formula <-  bf(
   N_pos_increment ~ lambda,
   nlf(lambda ~ log(Upois) +log_diff_exp( lognormal_lccdf_mod(tprev,mupois,sigmapois), lognormal_lccdf_mod(t,mupois,sigmapois)) ),# std incremental poisson model for N+ using modified version of lccdf for syntax and numerical accuracy in the tail
   nlf(Upois ~ exp(Upoisstd*log(20)+log(50))),
   mupois~1,
   Upoisstd ~1,
  nlf(sigmapois~exp(sigmapoisstd)),
  sigmapoisstd~1,
  family = poisson(),
  nl=TRUE)+
  bf(N_neg_increment | vint(Nprev)+vreal(t,tprev) ~ 1 ,
     mubin~1,
     sigmabin~1,
     family = binomsharedpars)

# specify std normal non-centred priors
mypriors <- c(
  prior(normal(0, 1),resp = "Nposincrement", nlpar = "Upoisstd"),
  #prior(normal(0, 1), resp = "Nnegincrement",dpar = "mu"),
  prior(normal(0, 1), resp = "Nposincrement",nlpar = "sigmapoisstd"),
  prior(normal(0, 1), class = "Intercept",resp = "Nnegincrement",dpar = "sigmabin"),
  prior(normal(0, 1), resp = "Nposincrement",nlpar = "mupois"),
  prior(normal(0, 1), class = "Intercept",resp = "Nnegincrement",dpar = "mubin")
  )
```

####run the new model
```{r}
prior_set = get_prior(formula,prior = mypriors, 
  stanvars = stanvar(scode = stan_functions, block = "functions"),
  data = standata, backend = "cmdstan")

model <- brm(
  formula,
  prior = mypriors,
  stanvars = stanvar(scode = stan_functions, block = "functions"),
  data = standata, backend = "cmdstan",
  control = list(adapt_delta = 0.99),
  seed = 1234, iter = 1000, 
  chains = 4, cores = 6,
  file = "frequencyCMDStan.rds")
```
This version fails to initialise, so we will modify the code and do some debugging. 
```{r}
stan_functions = "// we solve for #>0 at any point in time t  
vector N_ode(real t,//time
             vector N,// expected # of non-zero claims and expected # dropping to zero at time t. must be a vector so 2d. This is what is being solved for.
             real U,
             real U_p,
             real mu,
             real sigma,
             real mu_p,
             real sigma_p
             ) {
    vector[2] dNdt;
    dNdt[1] = U*lognormal_lpdf(t|mu,sigma)-N[1]*U_p*lognormal_lpdf(t|mu_p,sigma_p);// cumulative # claims >0
    dNdt[2] = N[1]*U_p*lognormal_lpdf(t|mu_p,sigma_p);
    return dNdt;// cumulative # claims dropped back to zero
}
// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] N,  // both N and N_neg
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dNdt[2];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu_p = theta[5];
    real sigma_p = theta[6];
    
    dNdt[1] = U*lognormal_lpdf(t|mu,sigma)-N[1]*U_p*lognormal_lpdf(t|mu_p,sigma_p);// cumulative # claims >0
    dNdt[2] = N[1]*U_p*lognormal_lpdf(t|mu_p,sigma_p);// cumulative # claims dropped back to zero
    return dNdt;
}

// Integrate ODE to solve for N at a point in time
real N_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  real returnpar;
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0.0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,1];// returns N only
  return returnpar;
}

// Integrate ODE to solve for N- at a point in time
real N_neg_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  real returnpar;
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0.0 , // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,2];// returns N- only
  return returnpar;
}

real binomsharedpars_lpmf(int Nnegincrement,
                          real Ubin,
                          real mubin,
                          real sigmabin,
                          int Nprev, 
                          real t,
                          real tprev,
                          real Upois,
                          real mupois,
                          real sigmapois
                          ){
    real p;
    p= Ubin*exp(log_diff_exp(lognormal_lccdf(tprev|mubin,sigmabin), lognormal_lccdf(t|mubin,sigmabin)));
    p = -(log(1+exp(-10*(p-1)))/10 -1);// use softplus to block approach to 1
    return binomial_lpmf(Nnegincrement | Nprev,p);
}


real lognormal_lccdf_mod(real a,real b,real c){
  return lognormal_lccdf(a|b,c);
}

"
```
 this worked byut it would be better if the n in the binomial distribution was Nprev + Nposincrement as this is strictly the maximum number of Nnegicrement claims in a period.
  We also are not using the ode solver at this stage, so we will need to import the additional data to solve that including N.

```{r}
# nlp_Nnegincrement_Ubin[n] naming conventions

binomsharedpars <- custom_family(
                    "binomsharedpars", dpars = c("mu","mubin","sigmabin"), # actually mu is                really the Ubin for the binomial 
                    links = c("log","identity","log"),
                    type = "int",# lpmf vs lpdf
                    vars = c("vint1[n]", # Nprev
                             "vint2[n]", # N
                             "vreal1[n]",# t
                             "vreal2[n]",# tprev
                             "nlp_Nposincrement_Upois[n]", #Upois
                             "nlp_Nposincrement_mupois[n]", #mupois
                             "nlp_Nposincrement_sigmapois[n]" #sigmapois
                             ) 
              )
```
and now modify the functions to accept the updated family
```{r}
stan_functions = "// we solve for #>0 at any point in time t  
vector N_ode(real t,//time
             vector N,// expected # of non-zero claims and expected # dropping to zero at time t. must be a vector so 2d. This is what is being solved for.
             real U,
             real U_p,
             real mu,
             real sigma,
             real mu_p,
             real sigma_p
             ) {
    vector[2] dNdt;
    dNdt[1] = exp(log_diff_exp(log(U)+lognormal_lpdf(t|mu,sigma),log(N[1])+log(U_p)+lognormal_lpdf(t|mu_p,sigma_p)));// cumulative # claims >0
    dNdt[2] = N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));
    print(dNdt[1],\" \",dNdt[2]);
    return dNdt;// cumulative # claims dropped back to zero
}
// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] N,  // both N and N_neg
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dNdt[2];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu_p = theta[5];
    real sigma_p = theta[6];
    
    dNdt[1] = U*exp(lognormal_lpdf(t|mu,sigma))-N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims >0
    dNdt[2] = N[1]*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims dropped back to zero
    return dNdt;
}

// Integrate ODE to solve for N at a point in time 
real N_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  real returnpar;
  
  // check gradients can be calculated
  N0[1] = U*exp(lognormal_lpdf(t|mu,sigma))-1.0*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims >0
    N0[2] = 1.0*U_p*exp(lognormal_lpdf(t|mu_p,sigma_p));// gradient of cumulative # claims dropped back to zero
  print(N0[1],\" \",N0[2]);
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0.0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,1];// returns N only
  return returnpar;
}

// Integrate ODE to solve for N- at a point in time
real N_neg_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  real returnpar;
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receive par as input
                         N0, // N and N- at t=0
                         0.0 , // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  returnpar = N[1,2];// returns N- only
  return returnpar;
}

real binomsharedpars_lpmf(int Nnegincrement,
                          real Ubin,
                          real mubin,
                          real sigmabin,
                          int Nprev,
                          int N,
                          real t,
                          real tprev,
                          real Upois,
                          real mupois,
                          real sigmapois
                          ){
    real p;
    //p= Ubin*exp(log_diff_exp(lognormal_lccdf(tprev|mubin,sigmabin), lognormal_lccdf(t|mubin,sigmabin)));
    p=N_int(t,Upois,Ubin,mupois,sigmapois,mubin,sigmabin);
    if(is_nan(p)==1){
      //print(t,\" \",Upois,\" \",Ubin,\" \",mupois,\" \",sigmapois,\" \",mubin,\" \",sigmabin);
    } 
    return binomial_lpmf(Nnegincrement | N+Nnegincrement, min([0.99,min([0.99, Ubin*exp(log_diff_exp(lognormal_lccdf(tprev|mubin,sigmabin), lognormal_lccdf(t|mubin,sigmabin)))])]) );

}


real lognormal_lccdf_mod(real a,real b,real c){
  return lognormal_lccdf(a|b,c);
}

"
```
and update the formula for the additional information being passed
```{r}
# writing the formula we are essentially declaring what the parameters need to be called
formula <-  bf(
   N_pos_increment ~ lambda,
   nlf(lambda ~ log(Upois) +log_diff_exp( lognormal_lccdf_mod(tprev,mupois,sigmapois), lognormal_lccdf_mod(t,mupois,sigmapois)) ),# std incremental poisson model for N+ using modified version of lccdf for syntax and numerical accuracy in the tail
   nlf(Upois ~ exp(Upoisstd*log(5)+log(10))),
   mupois~1,
   Upoisstd ~1,
  nlf(sigmapois~exp(sigmapoisstd)),
  sigmapoisstd~1,
  family = poisson(),
  nl=TRUE)+
  bf(N_neg_increment | vint(Nprev,N)+vreal(t,tprev) ~ 1 ,
     mubin~1,
     sigmabin~1,
     family = binomsharedpars)

# specify std normal non-centred priors
mypriors <- c(
  prior(normal(0, 1),resp = "Nposincrement", nlpar = "Upoisstd"),
  #prior(normal(0, 1), resp = "Nnegincrement",dpar = "mu"),
  prior(normal(0, 1), resp = "Nposincrement",nlpar = "sigmapoisstd"),
  prior(normal(0, 1), class = "Intercept",resp = "Nnegincrement",dpar = "sigmabin"),
  prior(normal(0, 1), resp = "Nposincrement",nlpar = "mupois"),
  prior(normal(0, 1), class = "Intercept",resp = "Nnegincrement",dpar = "mubin")
  )
```
now run the model again to check things are still working
```{r}
library(brms)
#testbrms = brm(y~1,data=data.frame(y=rnorm(100,0,2)), backend = "cmdstan")
model = brm(
  formula,
  prior = mypriors,
  stanvars = stanvar(scode = stan_functions, block = "functions"),
  data = standata, backend = "cmdstan",
  control = list(adapt_delta = 0.99),
  #seed = 1234, 
  iter = 1000, 
  chains = 4, cores = 6
  #file = "frequencyCMDStan3.rds"
  )
```
