---
title: "ULR models"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Intro

here we try to combine a frequency and average ckaim size model into an incurred model. we observe that there is a rate at which claims are transitioning back to zero. our intention is to model net non-zero claims above some very low threshold.

```{r installbrms}
library(devtools)
remove.packages(c("StanHeaders", "rstan"))
##install_github("hsbadr/rstan/StanHeaders@develop")
install.packages("StanHeaders", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
install.packages("RcppEigen", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
#install_version("RcppEigen", "0.3.3.9.1")
##install_github("hsbadr/rstan/rstan/rstan@develop")
install.packages("rstan", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
install_github("paul-buerkner/brms",dependencies = TRUE)
```
## cmdstanr install

```{r installcmdstanr, echo = FALSE}

# this code chunk is made redundant by the installation of the github versions on BRMS and cmdstanr into the docker image.
# see the "Dockerfile"
install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
library(cmdstanr)
check_cmdstan_toolchain(fix=TRUE)
install_cmdstan(cores = 6,overwrite=TRUE)
cmdstan_path()
cmdstan_version()

file <- file.path(cmdstan_path(), "examples", "bernoulli", "bernoulli.stan")
mod <- cmdstan_model(file)

data_list <- list(N = 10, y = c(0,1,0,0,0,0,0,0,0,1))

# confirming models can run and run in parallel
fit <- mod$sample(
  data = data_list,
  iter_warmup = 1000,
  iter_sampling = 1e5,
  seed = 123,
  chains = 4,
  parallel_chains = 4,
  refresh = 1e4
)
```
## set cmdstan to build models in the background

```{r cmdstanparser}
library(cmdstanr)

register_knitr_engine()
```

## model development
after looking into the problem further, it might be smart to set it up as an ODE model first.

### example
the example below is from the stan documentation. the syntax of the functions has changed recently, making it harder to just use what in on the internet. A great example from the older syntax is from Marcus Gessman on mages blog [mages blog ](https://magesblog.com/post/2021-02-08-fitting-multivariate-ode-models-with-brms/).

```{stan, output.var="testmodel"}
functions {
  vector sho(real t,
             vector y,
             real theta) {
    vector[2] dydt;
    dydt[1] = y[2];
    dydt[2] = -y[1] - theta * y[2];
    return dydt;
  }
}
data {
  int<lower=1> T;
  vector[2] y0;
  real t0;
  array[T] real ts;
  real theta;
}
model {
}
generated quantities {
  vector[2] y_sim[T] = ode_rk45(sho, y0, t0, ts, theta);
  // add measurement error
  for (t in 1:T) {
    y_sim[t, 1] += normal_rng(0, 0.1);
    y_sim[t, 2] += normal_rng(0, 0.1);
  }
}
```


### my first try
I will try to get something working below.

#### some basic points
Start by just saying the the integral of the pdf is the lambda for any given time period, where the number of reported non-zero claims (excluding those that go back to zero) at any point in time is a poisson distribution with mean lambda. An analytic solution exists in terms of ult*lognormal_cdf(t,mu,sigma) where Ult is the ultimate expected number of claims that were ever positive.
$$\frac{\partial \lambda}{\partial t} = U.lognormal_{pdf}(t,\mu,\sigma)$$
the analytic solution is then $$\lambda(t) = U.lognormal_{cdf}(t,\mu,\sigma)$$ 

where $\lambda$ is the expected cumulative (i.e. current actual) number of non zero claims ever reported at a given point in time. When time is infinity the expected claim count is $U$ (the ultimate expected number). 

We will implement this as a standard poisson frequency model where we count the incremental number of reported non-nil claims.

Similarly, we can represent the binomial rate of non-zero claims falling back to zero. This is unfortunately required at times as we are modelling net claims and there can easily be a significant number of "negative IBNR" in the late tail of the claim count triangulations.
$$\frac{\partial p}{\partial t} = U_plognormal_{pdf}(t,\mu_p,\sigma_p)$$
Then we can show the analytic solution for p:$$p(t)=U_plognormal_{cdf}(t,\mu,\sigma)$$
but unfortunately: $$N_-(a)=\int_0^a\frac{\partial p}{\partial t}N(t) \partial t $$
With a binomial distribution, the calculation is harder. Now we introduce the count of claims and the expected count of claims for the number of positive reported claims $N_+(t)$, the number of claims that have fallen back to zero $N_-(t)$ and the current actual number of non-zero claims $N$.An alternative for $N_-$ might now be: $$\frac{\partial \overline N_-}{\partial t}=\overline N \frac {\partial p}{\partial t}$$
which is only true over many samples but is easier to solve for.
Then we can represent a differential equation perhaps: 
$$\frac{\partial \overline{N}_-}{\partial t} = \overline N(t).U_p.lognormal_{pdf}(t,\mu_p,\sigma_p)$$
which involves no discrete numbers. 

The first step of the process we can state more easily:
$$N_+(t)=poisson(\lambda(t))$$
A simple poisson sample. So $$\overline{N}_+(t)=\lambda(t)$$
A much easier calculation.

Calculating $N(t)$ seems the hardest. We shall approximate $\overline N(t)$ with a differential equation:$$\frac {\partial \overline N}{\partial t}=\frac {\partial \overline N_+}{\partial t} - \frac {\partial \overline N_-}{\partial t}$$
which simplifies to:$$\frac {\partial \overline N}{\partial t}=U.lognormal_{pdf}(t,\mu,\sigma) - \overline N(t).U_p.lognormal_{pdf}(t,\mu_p,\sigma_p)$$
which contains only continuous numbers and can be solved for in stan using the PDE solver or the numerical integrator.


```{stan, output.var="odemodel", eval= false}

  // we solve for #>0 at any point in time t  
vector N_ode(real t,//time
             vector N,// expected # of non-zero claims and expected # dropping to zero at time t. must be a vector so 2d. This is what is being solved for.
             real U,
             real U_p,
             real mu,
             real sigma,
             real mu_p,
             real sigma_p
             ) {
    vector[2] dNdt;
    dNdt[1] = U*lognormal_lpdf(t,mu,sigma)-N[1]*U_p*lognormal_lpdf(t,mu_p,sigma_p);// cumulative # claims >0
    dNdt[2] = N[1]*U_p*lognormal_lpdf(t,mu_p,sigma_p);
    return dNdt;// cumulative # claims dropped back to zero
}
// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] N,  // both N and N_neg
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dNdt[2];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu = theta[5];
    real sigma_p = theta[6];
    
    dNdt[1] = U*lognormal_lpdf(t,mu,sigma)-N[1]*U_p*lognormal_lpdf(t,mu_p,sigma_p);// cumulative # claims >0
    dNdt[2] = N[1]*U_p*lognormal_lpdf(t,mu_p,sigma_p);// cumulative # claims dropped back to zero
    return dNdt;
}

// Integrate ODE to solve for N at a point in time
real N_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  return N[1];// returns N only
}

// Integrate ODE to solve for N- at a point in time
real N_neg_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  return N[2];// returns N- only
}

```
put this code into a text string and set up a brms formula
```{r}
library(brms)
functions = "// we solve for #>0 at any point in time t  
vector N_ode(real t,//time
             vector N,// expected # of non-zero claims and expected # dropping to zero at time t. must be a vector so 2d. This is what is being solved for.
             real U,
             real U_p,
             real mu,
             real sigma,
             real mu_p,
             real sigma_p
             ) {
    vector[2] dNdt;
    dNdt[1] = U*lognormal_lpdf(t,mu,sigma)-N[1]*U_p*lognormal_lpdf(t,mu_p,sigma_p);// cumulative # claims >0
    dNdt[2] = N[1]*U_p*lognormal_lpdf(t,mu_p,sigma_p);
    return dNdt;// cumulative # claims dropped back to zero
}
// modify signature for calls from the integrator to output N
real[] N_ode_int(real t, 
                  real [] N,  // both N and N_neg
                  real [] theta, // model parameters
              real [] x_r, int[] x_i
             ) {
    real dNdt[2];
    real U = theta[1];
    real U_p = theta[2];
    real mu = theta[3];
    real sigma = theta[4];
    real mu = theta[5];
    real sigma_p = theta[6];
    
    dNdt[1] = U*lognormal_lpdf(t,mu,sigma)-N[1]*U_p*lognormal_lpdf(t,mu_p,sigma_p);// cumulative # claims >0
    dNdt[2] = N[1]*U_p*lognormal_lpdf(t,mu_p,sigma_p);// cumulative # claims dropped back to zero
    return dNdt;
}

// Integrate ODE to solve for N at a point in time
real N_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  return N[1];// returns N only
}

// Integrate ODE to solve for N- at a point in time
real N_neg_int(real t,
        real U,
        real U_p,
        real mu,
        real sigma,
        real mu_p,
        real sigma_p
        ) {
  real N0[2];     // Initial values
  real par[6];  // Parameters
  real N[1, 2];   // ODE solution at time t
  // Set initial values. There should be no claims initially
  N0[1] = 0; 
  N0[2] = 0;
  // Set parameters
  par[1] = U;
  par[2] = U_p;
  par[3] = mu; 
  par[4] = sigma;
  par[5] = mu_p; 
  par[6] = sigma_p;
  
  // Solve ODEs 
  //array[,] real integrate_ode_rk45(function ode, array[] real initial_state, real initial_time, array[] real times, array[] real theta, array[] real x_r, array[] int x_i, real rel_tol, real abs_tol, int max_num_steps)
  N = integrate_ode_rk45(N_ode_int, //function that will receicve par as input
                         N0, // N and N- at t=0
                         0, // initial t=0
                         rep_array(t, 1), //array of times at which to find N
                         par,// set of parameters for ode function
                         rep_array(0.0, 0), // not needed real data
                         rep_array(1, 1),// not needed int data
                         1e-6, 1e-5, 1e3); // max steps
  // Return relevant values
  return N[2];// returns N- only
}"

# writing the formula we are essentially declaring what the parameters need to be called
fm <-  bf(
   N_pos_increment ~ log(U) +log_diff_exp( lognormal_lpdf(t,mu,sigma), lognormal_lpdf(tprev,mu,sigma)) ,# std incremental poisson model for N+
  family = poisson(),
  nl = TRUE) + bf( N_neg_increment | trials(Nprev) ~ (N_neg_int(t,U,Up,mu,sigma,mup,sigmap)-N_neg_int(tprev,U,Up,mu,sigma,mup,sigmap))/N_int(tprev,U,Up,mu,sigma,mup,sigmap),# approximation
  family = binomial("identity"),
  nl = TRUE )+
  nlf(U~exp(Ustd))+
  nlf(Up~exp(Upstd))+
  lf(mu~1)+
  lf(mup~1)+
  nlf(sigma~exp(sigmastd))+

  
```
